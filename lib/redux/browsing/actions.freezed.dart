// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'actions.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$BrowseQuestionTearOff {
  const _$BrowseQuestionTearOff();

  _BrowseQuestion call({@required QuestionInfo info}) {
    return _BrowseQuestion(
      info: info,
    );
  }
}

// ignore: unused_element
const $BrowseQuestion = _$BrowseQuestionTearOff();

mixin _$BrowseQuestion {
  QuestionInfo get info;

  $BrowseQuestionCopyWith<BrowseQuestion> get copyWith;
}

abstract class $BrowseQuestionCopyWith<$Res> {
  factory $BrowseQuestionCopyWith(
          BrowseQuestion value, $Res Function(BrowseQuestion) then) =
      _$BrowseQuestionCopyWithImpl<$Res>;
  $Res call({QuestionInfo info});

  $QuestionInfoCopyWith<$Res> get info;
}

class _$BrowseQuestionCopyWithImpl<$Res>
    implements $BrowseQuestionCopyWith<$Res> {
  _$BrowseQuestionCopyWithImpl(this._value, this._then);

  final BrowseQuestion _value;
  // ignore: unused_field
  final $Res Function(BrowseQuestion) _then;

  @override
  $Res call({
    Object info = freezed,
  }) {
    return _then(_value.copyWith(
      info: info == freezed ? _value.info : info as QuestionInfo,
    ));
  }

  @override
  $QuestionInfoCopyWith<$Res> get info {
    if (_value.info == null) {
      return null;
    }
    return $QuestionInfoCopyWith<$Res>(_value.info, (value) {
      return _then(_value.copyWith(info: value));
    });
  }
}

abstract class _$BrowseQuestionCopyWith<$Res>
    implements $BrowseQuestionCopyWith<$Res> {
  factory _$BrowseQuestionCopyWith(
          _BrowseQuestion value, $Res Function(_BrowseQuestion) then) =
      __$BrowseQuestionCopyWithImpl<$Res>;
  @override
  $Res call({QuestionInfo info});

  @override
  $QuestionInfoCopyWith<$Res> get info;
}

class __$BrowseQuestionCopyWithImpl<$Res>
    extends _$BrowseQuestionCopyWithImpl<$Res>
    implements _$BrowseQuestionCopyWith<$Res> {
  __$BrowseQuestionCopyWithImpl(
      _BrowseQuestion _value, $Res Function(_BrowseQuestion) _then)
      : super(_value, (v) => _then(v as _BrowseQuestion));

  @override
  _BrowseQuestion get _value => super._value as _BrowseQuestion;

  @override
  $Res call({
    Object info = freezed,
  }) {
    return _then(_BrowseQuestion(
      info: info == freezed ? _value.info : info as QuestionInfo,
    ));
  }
}

class _$_BrowseQuestion
    with DiagnosticableTreeMixin
    implements _BrowseQuestion {
  const _$_BrowseQuestion({@required this.info}) : assert(info != null);

  @override
  final QuestionInfo info;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BrowseQuestion(info: $info)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BrowseQuestion'))
      ..add(DiagnosticsProperty('info', info));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _BrowseQuestion &&
            (identical(other.info, info) ||
                const DeepCollectionEquality().equals(other.info, info)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(info);

  @override
  _$BrowseQuestionCopyWith<_BrowseQuestion> get copyWith =>
      __$BrowseQuestionCopyWithImpl<_BrowseQuestion>(this, _$identity);
}

abstract class _BrowseQuestion implements BrowseQuestion {
  const factory _BrowseQuestion({@required QuestionInfo info}) =
      _$_BrowseQuestion;

  @override
  QuestionInfo get info;
  @override
  _$BrowseQuestionCopyWith<_BrowseQuestion> get copyWith;
}

class _$BrowseTourTearOff {
  const _$BrowseTourTearOff();

  _BrowseTour call({@required TourInfo info}) {
    return _BrowseTour(
      info: info,
    );
  }
}

// ignore: unused_element
const $BrowseTour = _$BrowseTourTearOff();

mixin _$BrowseTour {
  TourInfo get info;

  $BrowseTourCopyWith<BrowseTour> get copyWith;
}

abstract class $BrowseTourCopyWith<$Res> {
  factory $BrowseTourCopyWith(
          BrowseTour value, $Res Function(BrowseTour) then) =
      _$BrowseTourCopyWithImpl<$Res>;
  $Res call({TourInfo info});

  $TourInfoCopyWith<$Res> get info;
}

class _$BrowseTourCopyWithImpl<$Res> implements $BrowseTourCopyWith<$Res> {
  _$BrowseTourCopyWithImpl(this._value, this._then);

  final BrowseTour _value;
  // ignore: unused_field
  final $Res Function(BrowseTour) _then;

  @override
  $Res call({
    Object info = freezed,
  }) {
    return _then(_value.copyWith(
      info: info == freezed ? _value.info : info as TourInfo,
    ));
  }

  @override
  $TourInfoCopyWith<$Res> get info {
    if (_value.info == null) {
      return null;
    }
    return $TourInfoCopyWith<$Res>(_value.info, (value) {
      return _then(_value.copyWith(info: value));
    });
  }
}

abstract class _$BrowseTourCopyWith<$Res> implements $BrowseTourCopyWith<$Res> {
  factory _$BrowseTourCopyWith(
          _BrowseTour value, $Res Function(_BrowseTour) then) =
      __$BrowseTourCopyWithImpl<$Res>;
  @override
  $Res call({TourInfo info});

  @override
  $TourInfoCopyWith<$Res> get info;
}

class __$BrowseTourCopyWithImpl<$Res> extends _$BrowseTourCopyWithImpl<$Res>
    implements _$BrowseTourCopyWith<$Res> {
  __$BrowseTourCopyWithImpl(
      _BrowseTour _value, $Res Function(_BrowseTour) _then)
      : super(_value, (v) => _then(v as _BrowseTour));

  @override
  _BrowseTour get _value => super._value as _BrowseTour;

  @override
  $Res call({
    Object info = freezed,
  }) {
    return _then(_BrowseTour(
      info: info == freezed ? _value.info : info as TourInfo,
    ));
  }
}

class _$_BrowseTour with DiagnosticableTreeMixin implements _BrowseTour {
  const _$_BrowseTour({@required this.info}) : assert(info != null);

  @override
  final TourInfo info;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BrowseTour(info: $info)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BrowseTour'))
      ..add(DiagnosticsProperty('info', info));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _BrowseTour &&
            (identical(other.info, info) ||
                const DeepCollectionEquality().equals(other.info, info)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(info);

  @override
  _$BrowseTourCopyWith<_BrowseTour> get copyWith =>
      __$BrowseTourCopyWithImpl<_BrowseTour>(this, _$identity);
}

abstract class _BrowseTour implements BrowseTour {
  const factory _BrowseTour({@required TourInfo info}) = _$_BrowseTour;

  @override
  TourInfo get info;
  @override
  _$BrowseTourCopyWith<_BrowseTour> get copyWith;
}

class _$BrowseTournamentTearOff {
  const _$BrowseTournamentTearOff();

  _BrowseTournament call({@required TournamentInfo info}) {
    return _BrowseTournament(
      info: info,
    );
  }
}

// ignore: unused_element
const $BrowseTournament = _$BrowseTournamentTearOff();

mixin _$BrowseTournament {
  TournamentInfo get info;

  $BrowseTournamentCopyWith<BrowseTournament> get copyWith;
}

abstract class $BrowseTournamentCopyWith<$Res> {
  factory $BrowseTournamentCopyWith(
          BrowseTournament value, $Res Function(BrowseTournament) then) =
      _$BrowseTournamentCopyWithImpl<$Res>;
  $Res call({TournamentInfo info});

  $TournamentInfoCopyWith<$Res> get info;
}

class _$BrowseTournamentCopyWithImpl<$Res>
    implements $BrowseTournamentCopyWith<$Res> {
  _$BrowseTournamentCopyWithImpl(this._value, this._then);

  final BrowseTournament _value;
  // ignore: unused_field
  final $Res Function(BrowseTournament) _then;

  @override
  $Res call({
    Object info = freezed,
  }) {
    return _then(_value.copyWith(
      info: info == freezed ? _value.info : info as TournamentInfo,
    ));
  }

  @override
  $TournamentInfoCopyWith<$Res> get info {
    if (_value.info == null) {
      return null;
    }
    return $TournamentInfoCopyWith<$Res>(_value.info, (value) {
      return _then(_value.copyWith(info: value));
    });
  }
}

abstract class _$BrowseTournamentCopyWith<$Res>
    implements $BrowseTournamentCopyWith<$Res> {
  factory _$BrowseTournamentCopyWith(
          _BrowseTournament value, $Res Function(_BrowseTournament) then) =
      __$BrowseTournamentCopyWithImpl<$Res>;
  @override
  $Res call({TournamentInfo info});

  @override
  $TournamentInfoCopyWith<$Res> get info;
}

class __$BrowseTournamentCopyWithImpl<$Res>
    extends _$BrowseTournamentCopyWithImpl<$Res>
    implements _$BrowseTournamentCopyWith<$Res> {
  __$BrowseTournamentCopyWithImpl(
      _BrowseTournament _value, $Res Function(_BrowseTournament) _then)
      : super(_value, (v) => _then(v as _BrowseTournament));

  @override
  _BrowseTournament get _value => super._value as _BrowseTournament;

  @override
  $Res call({
    Object info = freezed,
  }) {
    return _then(_BrowseTournament(
      info: info == freezed ? _value.info : info as TournamentInfo,
    ));
  }
}

class _$_BrowseTournament
    with DiagnosticableTreeMixin
    implements _BrowseTournament {
  const _$_BrowseTournament({@required this.info}) : assert(info != null);

  @override
  final TournamentInfo info;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BrowseTournament(info: $info)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BrowseTournament'))
      ..add(DiagnosticsProperty('info', info));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _BrowseTournament &&
            (identical(other.info, info) ||
                const DeepCollectionEquality().equals(other.info, info)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(info);

  @override
  _$BrowseTournamentCopyWith<_BrowseTournament> get copyWith =>
      __$BrowseTournamentCopyWithImpl<_BrowseTournament>(this, _$identity);
}

abstract class _BrowseTournament implements BrowseTournament {
  const factory _BrowseTournament({@required TournamentInfo info}) =
      _$_BrowseTournament;

  @override
  TournamentInfo get info;
  @override
  _$BrowseTournamentCopyWith<_BrowseTournament> get copyWith;
}

class _$BrowseDatabaseTearOff {
  const _$BrowseDatabaseTearOff();

  _BrowseDatabase call() {
    return const _BrowseDatabase();
  }
}

// ignore: unused_element
const $BrowseDatabase = _$BrowseDatabaseTearOff();

mixin _$BrowseDatabase {}

abstract class $BrowseDatabaseCopyWith<$Res> {
  factory $BrowseDatabaseCopyWith(
          BrowseDatabase value, $Res Function(BrowseDatabase) then) =
      _$BrowseDatabaseCopyWithImpl<$Res>;
}

class _$BrowseDatabaseCopyWithImpl<$Res>
    implements $BrowseDatabaseCopyWith<$Res> {
  _$BrowseDatabaseCopyWithImpl(this._value, this._then);

  final BrowseDatabase _value;
  // ignore: unused_field
  final $Res Function(BrowseDatabase) _then;
}

abstract class _$BrowseDatabaseCopyWith<$Res> {
  factory _$BrowseDatabaseCopyWith(
          _BrowseDatabase value, $Res Function(_BrowseDatabase) then) =
      __$BrowseDatabaseCopyWithImpl<$Res>;
}

class __$BrowseDatabaseCopyWithImpl<$Res>
    extends _$BrowseDatabaseCopyWithImpl<$Res>
    implements _$BrowseDatabaseCopyWith<$Res> {
  __$BrowseDatabaseCopyWithImpl(
      _BrowseDatabase _value, $Res Function(_BrowseDatabase) _then)
      : super(_value, (v) => _then(v as _BrowseDatabase));

  @override
  _BrowseDatabase get _value => super._value as _BrowseDatabase;
}

class _$_BrowseDatabase
    with DiagnosticableTreeMixin
    implements _BrowseDatabase {
  const _$_BrowseDatabase();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BrowseDatabase()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'BrowseDatabase'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _BrowseDatabase);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _BrowseDatabase implements BrowseDatabase {
  const factory _BrowseDatabase() = _$_BrowseDatabase;
}
