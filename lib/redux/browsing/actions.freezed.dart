// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'actions.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$BrowseQuestionTearOff {
  const _$BrowseQuestionTearOff();

  _BrowseQuestion call({@required Question question}) {
    return _BrowseQuestion(
      question: question,
    );
  }
}

// ignore: unused_element
const $BrowseQuestion = _$BrowseQuestionTearOff();

mixin _$BrowseQuestion {
  Question get question;

  $BrowseQuestionCopyWith<BrowseQuestion> get copyWith;
}

abstract class $BrowseQuestionCopyWith<$Res> {
  factory $BrowseQuestionCopyWith(
          BrowseQuestion value, $Res Function(BrowseQuestion) then) =
      _$BrowseQuestionCopyWithImpl<$Res>;
  $Res call({Question question});

  $QuestionCopyWith<$Res> get question;
}

class _$BrowseQuestionCopyWithImpl<$Res>
    implements $BrowseQuestionCopyWith<$Res> {
  _$BrowseQuestionCopyWithImpl(this._value, this._then);

  final BrowseQuestion _value;
  // ignore: unused_field
  final $Res Function(BrowseQuestion) _then;

  @override
  $Res call({
    Object question = freezed,
  }) {
    return _then(_value.copyWith(
      question: question == freezed ? _value.question : question as Question,
    ));
  }

  @override
  $QuestionCopyWith<$Res> get question {
    if (_value.question == null) {
      return null;
    }
    return $QuestionCopyWith<$Res>(_value.question, (value) {
      return _then(_value.copyWith(question: value));
    });
  }
}

abstract class _$BrowseQuestionCopyWith<$Res>
    implements $BrowseQuestionCopyWith<$Res> {
  factory _$BrowseQuestionCopyWith(
          _BrowseQuestion value, $Res Function(_BrowseQuestion) then) =
      __$BrowseQuestionCopyWithImpl<$Res>;
  @override
  $Res call({Question question});

  @override
  $QuestionCopyWith<$Res> get question;
}

class __$BrowseQuestionCopyWithImpl<$Res>
    extends _$BrowseQuestionCopyWithImpl<$Res>
    implements _$BrowseQuestionCopyWith<$Res> {
  __$BrowseQuestionCopyWithImpl(
      _BrowseQuestion _value, $Res Function(_BrowseQuestion) _then)
      : super(_value, (v) => _then(v as _BrowseQuestion));

  @override
  _BrowseQuestion get _value => super._value as _BrowseQuestion;

  @override
  $Res call({
    Object question = freezed,
  }) {
    return _then(_BrowseQuestion(
      question: question == freezed ? _value.question : question as Question,
    ));
  }
}

class _$_BrowseQuestion
    with DiagnosticableTreeMixin
    implements _BrowseQuestion {
  const _$_BrowseQuestion({@required this.question}) : assert(question != null);

  @override
  final Question question;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BrowseQuestion(question: $question)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BrowseQuestion'))
      ..add(DiagnosticsProperty('question', question));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _BrowseQuestion &&
            (identical(other.question, question) ||
                const DeepCollectionEquality()
                    .equals(other.question, question)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(question);

  @override
  _$BrowseQuestionCopyWith<_BrowseQuestion> get copyWith =>
      __$BrowseQuestionCopyWithImpl<_BrowseQuestion>(this, _$identity);
}

abstract class _BrowseQuestion implements BrowseQuestion {
  const factory _BrowseQuestion({@required Question question}) =
      _$_BrowseQuestion;

  @override
  Question get question;
  @override
  _$BrowseQuestionCopyWith<_BrowseQuestion> get copyWith;
}

class _$BrowseTourTearOff {
  const _$BrowseTourTearOff();

  _BrowseTour call({@required Tour tour}) {
    return _BrowseTour(
      tour: tour,
    );
  }
}

// ignore: unused_element
const $BrowseTour = _$BrowseTourTearOff();

mixin _$BrowseTour {
  Tour get tour;

  $BrowseTourCopyWith<BrowseTour> get copyWith;
}

abstract class $BrowseTourCopyWith<$Res> {
  factory $BrowseTourCopyWith(
          BrowseTour value, $Res Function(BrowseTour) then) =
      _$BrowseTourCopyWithImpl<$Res>;
  $Res call({Tour tour});

  $TourCopyWith<$Res> get tour;
}

class _$BrowseTourCopyWithImpl<$Res> implements $BrowseTourCopyWith<$Res> {
  _$BrowseTourCopyWithImpl(this._value, this._then);

  final BrowseTour _value;
  // ignore: unused_field
  final $Res Function(BrowseTour) _then;

  @override
  $Res call({
    Object tour = freezed,
  }) {
    return _then(_value.copyWith(
      tour: tour == freezed ? _value.tour : tour as Tour,
    ));
  }

  @override
  $TourCopyWith<$Res> get tour {
    if (_value.tour == null) {
      return null;
    }
    return $TourCopyWith<$Res>(_value.tour, (value) {
      return _then(_value.copyWith(tour: value));
    });
  }
}

abstract class _$BrowseTourCopyWith<$Res> implements $BrowseTourCopyWith<$Res> {
  factory _$BrowseTourCopyWith(
          _BrowseTour value, $Res Function(_BrowseTour) then) =
      __$BrowseTourCopyWithImpl<$Res>;
  @override
  $Res call({Tour tour});

  @override
  $TourCopyWith<$Res> get tour;
}

class __$BrowseTourCopyWithImpl<$Res> extends _$BrowseTourCopyWithImpl<$Res>
    implements _$BrowseTourCopyWith<$Res> {
  __$BrowseTourCopyWithImpl(
      _BrowseTour _value, $Res Function(_BrowseTour) _then)
      : super(_value, (v) => _then(v as _BrowseTour));

  @override
  _BrowseTour get _value => super._value as _BrowseTour;

  @override
  $Res call({
    Object tour = freezed,
  }) {
    return _then(_BrowseTour(
      tour: tour == freezed ? _value.tour : tour as Tour,
    ));
  }
}

class _$_BrowseTour with DiagnosticableTreeMixin implements _BrowseTour {
  const _$_BrowseTour({@required this.tour}) : assert(tour != null);

  @override
  final Tour tour;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BrowseTour(tour: $tour)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BrowseTour'))
      ..add(DiagnosticsProperty('tour', tour));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _BrowseTour &&
            (identical(other.tour, tour) ||
                const DeepCollectionEquality().equals(other.tour, tour)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(tour);

  @override
  _$BrowseTourCopyWith<_BrowseTour> get copyWith =>
      __$BrowseTourCopyWithImpl<_BrowseTour>(this, _$identity);
}

abstract class _BrowseTour implements BrowseTour {
  const factory _BrowseTour({@required Tour tour}) = _$_BrowseTour;

  @override
  Tour get tour;
  @override
  _$BrowseTourCopyWith<_BrowseTour> get copyWith;
}

class _$BrowseTournamentTearOff {
  const _$BrowseTournamentTearOff();

  _BrowseTournament call({@required TournamentInfo info}) {
    return _BrowseTournament(
      info: info,
    );
  }
}

// ignore: unused_element
const $BrowseTournament = _$BrowseTournamentTearOff();

mixin _$BrowseTournament {
  TournamentInfo get info;

  $BrowseTournamentCopyWith<BrowseTournament> get copyWith;
}

abstract class $BrowseTournamentCopyWith<$Res> {
  factory $BrowseTournamentCopyWith(
          BrowseTournament value, $Res Function(BrowseTournament) then) =
      _$BrowseTournamentCopyWithImpl<$Res>;
  $Res call({TournamentInfo info});

  $TournamentInfoCopyWith<$Res> get info;
}

class _$BrowseTournamentCopyWithImpl<$Res>
    implements $BrowseTournamentCopyWith<$Res> {
  _$BrowseTournamentCopyWithImpl(this._value, this._then);

  final BrowseTournament _value;
  // ignore: unused_field
  final $Res Function(BrowseTournament) _then;

  @override
  $Res call({
    Object info = freezed,
  }) {
    return _then(_value.copyWith(
      info: info == freezed ? _value.info : info as TournamentInfo,
    ));
  }

  @override
  $TournamentInfoCopyWith<$Res> get info {
    if (_value.info == null) {
      return null;
    }
    return $TournamentInfoCopyWith<$Res>(_value.info, (value) {
      return _then(_value.copyWith(info: value));
    });
  }
}

abstract class _$BrowseTournamentCopyWith<$Res>
    implements $BrowseTournamentCopyWith<$Res> {
  factory _$BrowseTournamentCopyWith(
          _BrowseTournament value, $Res Function(_BrowseTournament) then) =
      __$BrowseTournamentCopyWithImpl<$Res>;
  @override
  $Res call({TournamentInfo info});

  @override
  $TournamentInfoCopyWith<$Res> get info;
}

class __$BrowseTournamentCopyWithImpl<$Res>
    extends _$BrowseTournamentCopyWithImpl<$Res>
    implements _$BrowseTournamentCopyWith<$Res> {
  __$BrowseTournamentCopyWithImpl(
      _BrowseTournament _value, $Res Function(_BrowseTournament) _then)
      : super(_value, (v) => _then(v as _BrowseTournament));

  @override
  _BrowseTournament get _value => super._value as _BrowseTournament;

  @override
  $Res call({
    Object info = freezed,
  }) {
    return _then(_BrowseTournament(
      info: info == freezed ? _value.info : info as TournamentInfo,
    ));
  }
}

class _$_BrowseTournament
    with DiagnosticableTreeMixin
    implements _BrowseTournament {
  const _$_BrowseTournament({@required this.info}) : assert(info != null);

  @override
  final TournamentInfo info;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BrowseTournament(info: $info)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BrowseTournament'))
      ..add(DiagnosticsProperty('info', info));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _BrowseTournament &&
            (identical(other.info, info) ||
                const DeepCollectionEquality().equals(other.info, info)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(info);

  @override
  _$BrowseTournamentCopyWith<_BrowseTournament> get copyWith =>
      __$BrowseTournamentCopyWithImpl<_BrowseTournament>(this, _$identity);
}

abstract class _BrowseTournament implements BrowseTournament {
  const factory _BrowseTournament({@required TournamentInfo info}) =
      _$_BrowseTournament;

  @override
  TournamentInfo get info;
  @override
  _$BrowseTournamentCopyWith<_BrowseTournament> get copyWith;
}
