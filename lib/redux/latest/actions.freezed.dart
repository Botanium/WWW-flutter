// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'actions.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$InitLatestTournamentsTearOff {
  const _$InitLatestTournamentsTearOff();

  _InitLatestTournaments call() {
    return const _InitLatestTournaments();
  }
}

// ignore: unused_element
const $InitLatestTournaments = _$InitLatestTournamentsTearOff();

mixin _$InitLatestTournaments {}

abstract class $InitLatestTournamentsCopyWith<$Res> {
  factory $InitLatestTournamentsCopyWith(InitLatestTournaments value,
          $Res Function(InitLatestTournaments) then) =
      _$InitLatestTournamentsCopyWithImpl<$Res>;
}

class _$InitLatestTournamentsCopyWithImpl<$Res>
    implements $InitLatestTournamentsCopyWith<$Res> {
  _$InitLatestTournamentsCopyWithImpl(this._value, this._then);

  final InitLatestTournaments _value;
  // ignore: unused_field
  final $Res Function(InitLatestTournaments) _then;
}

abstract class _$InitLatestTournamentsCopyWith<$Res> {
  factory _$InitLatestTournamentsCopyWith(_InitLatestTournaments value,
          $Res Function(_InitLatestTournaments) then) =
      __$InitLatestTournamentsCopyWithImpl<$Res>;
}

class __$InitLatestTournamentsCopyWithImpl<$Res>
    extends _$InitLatestTournamentsCopyWithImpl<$Res>
    implements _$InitLatestTournamentsCopyWith<$Res> {
  __$InitLatestTournamentsCopyWithImpl(_InitLatestTournaments _value,
      $Res Function(_InitLatestTournaments) _then)
      : super(_value, (v) => _then(v as _InitLatestTournaments));

  @override
  _InitLatestTournaments get _value => super._value as _InitLatestTournaments;
}

class _$_InitLatestTournaments
    with DiagnosticableTreeMixin
    implements _InitLatestTournaments {
  const _$_InitLatestTournaments();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'InitLatestTournaments()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'InitLatestTournaments'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _InitLatestTournaments);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _InitLatestTournaments implements InitLatestTournaments {
  const factory _InitLatestTournaments() = _$_InitLatestTournaments;
}

class _$RefreshLatestTournamentsTearOff {
  const _$RefreshLatestTournamentsTearOff();

  _RefreshLatestTournaments call() {
    return const _RefreshLatestTournaments();
  }
}

// ignore: unused_element
const $RefreshLatestTournaments = _$RefreshLatestTournamentsTearOff();

mixin _$RefreshLatestTournaments {}

abstract class $RefreshLatestTournamentsCopyWith<$Res> {
  factory $RefreshLatestTournamentsCopyWith(RefreshLatestTournaments value,
          $Res Function(RefreshLatestTournaments) then) =
      _$RefreshLatestTournamentsCopyWithImpl<$Res>;
}

class _$RefreshLatestTournamentsCopyWithImpl<$Res>
    implements $RefreshLatestTournamentsCopyWith<$Res> {
  _$RefreshLatestTournamentsCopyWithImpl(this._value, this._then);

  final RefreshLatestTournaments _value;
  // ignore: unused_field
  final $Res Function(RefreshLatestTournaments) _then;
}

abstract class _$RefreshLatestTournamentsCopyWith<$Res> {
  factory _$RefreshLatestTournamentsCopyWith(_RefreshLatestTournaments value,
          $Res Function(_RefreshLatestTournaments) then) =
      __$RefreshLatestTournamentsCopyWithImpl<$Res>;
}

class __$RefreshLatestTournamentsCopyWithImpl<$Res>
    extends _$RefreshLatestTournamentsCopyWithImpl<$Res>
    implements _$RefreshLatestTournamentsCopyWith<$Res> {
  __$RefreshLatestTournamentsCopyWithImpl(_RefreshLatestTournaments _value,
      $Res Function(_RefreshLatestTournaments) _then)
      : super(_value, (v) => _then(v as _RefreshLatestTournaments));

  @override
  _RefreshLatestTournaments get _value =>
      super._value as _RefreshLatestTournaments;
}

class _$_RefreshLatestTournaments
    with DiagnosticableTreeMixin
    implements _RefreshLatestTournaments {
  const _$_RefreshLatestTournaments();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'RefreshLatestTournaments()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'RefreshLatestTournaments'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _RefreshLatestTournaments);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _RefreshLatestTournaments implements RefreshLatestTournaments {
  const factory _RefreshLatestTournaments() = _$_RefreshLatestTournaments;
}

class _$LoadLatestTournamentsTearOff {
  const _$LoadLatestTournamentsTearOff();

  _LoadLatestTournaments call() {
    return const _LoadLatestTournaments();
  }
}

// ignore: unused_element
const $LoadLatestTournaments = _$LoadLatestTournamentsTearOff();

mixin _$LoadLatestTournaments {}

abstract class $LoadLatestTournamentsCopyWith<$Res> {
  factory $LoadLatestTournamentsCopyWith(LoadLatestTournaments value,
          $Res Function(LoadLatestTournaments) then) =
      _$LoadLatestTournamentsCopyWithImpl<$Res>;
}

class _$LoadLatestTournamentsCopyWithImpl<$Res>
    implements $LoadLatestTournamentsCopyWith<$Res> {
  _$LoadLatestTournamentsCopyWithImpl(this._value, this._then);

  final LoadLatestTournaments _value;
  // ignore: unused_field
  final $Res Function(LoadLatestTournaments) _then;
}

abstract class _$LoadLatestTournamentsCopyWith<$Res> {
  factory _$LoadLatestTournamentsCopyWith(_LoadLatestTournaments value,
          $Res Function(_LoadLatestTournaments) then) =
      __$LoadLatestTournamentsCopyWithImpl<$Res>;
}

class __$LoadLatestTournamentsCopyWithImpl<$Res>
    extends _$LoadLatestTournamentsCopyWithImpl<$Res>
    implements _$LoadLatestTournamentsCopyWith<$Res> {
  __$LoadLatestTournamentsCopyWithImpl(_LoadLatestTournaments _value,
      $Res Function(_LoadLatestTournaments) _then)
      : super(_value, (v) => _then(v as _LoadLatestTournaments));

  @override
  _LoadLatestTournaments get _value => super._value as _LoadLatestTournaments;
}

class _$_LoadLatestTournaments
    with DiagnosticableTreeMixin
    implements _LoadLatestTournaments {
  const _$_LoadLatestTournaments();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoadLatestTournaments()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'LoadLatestTournaments'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _LoadLatestTournaments);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _LoadLatestTournaments implements LoadLatestTournaments {
  const factory _LoadLatestTournaments() = _$_LoadLatestTournaments;
}

class _$LatestTournamentsIsLoadingTearOff {
  const _$LatestTournamentsIsLoadingTearOff();

  _LatestTournamentsIsLoading call() {
    return const _LatestTournamentsIsLoading();
  }
}

// ignore: unused_element
const $LatestTournamentsIsLoading = _$LatestTournamentsIsLoadingTearOff();

mixin _$LatestTournamentsIsLoading {}

abstract class $LatestTournamentsIsLoadingCopyWith<$Res> {
  factory $LatestTournamentsIsLoadingCopyWith(LatestTournamentsIsLoading value,
          $Res Function(LatestTournamentsIsLoading) then) =
      _$LatestTournamentsIsLoadingCopyWithImpl<$Res>;
}

class _$LatestTournamentsIsLoadingCopyWithImpl<$Res>
    implements $LatestTournamentsIsLoadingCopyWith<$Res> {
  _$LatestTournamentsIsLoadingCopyWithImpl(this._value, this._then);

  final LatestTournamentsIsLoading _value;
  // ignore: unused_field
  final $Res Function(LatestTournamentsIsLoading) _then;
}

abstract class _$LatestTournamentsIsLoadingCopyWith<$Res> {
  factory _$LatestTournamentsIsLoadingCopyWith(
          _LatestTournamentsIsLoading value,
          $Res Function(_LatestTournamentsIsLoading) then) =
      __$LatestTournamentsIsLoadingCopyWithImpl<$Res>;
}

class __$LatestTournamentsIsLoadingCopyWithImpl<$Res>
    extends _$LatestTournamentsIsLoadingCopyWithImpl<$Res>
    implements _$LatestTournamentsIsLoadingCopyWith<$Res> {
  __$LatestTournamentsIsLoadingCopyWithImpl(_LatestTournamentsIsLoading _value,
      $Res Function(_LatestTournamentsIsLoading) _then)
      : super(_value, (v) => _then(v as _LatestTournamentsIsLoading));

  @override
  _LatestTournamentsIsLoading get _value =>
      super._value as _LatestTournamentsIsLoading;
}

class _$_LatestTournamentsIsLoading
    with DiagnosticableTreeMixin
    implements _LatestTournamentsIsLoading {
  const _$_LatestTournamentsIsLoading();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LatestTournamentsIsLoading()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'LatestTournamentsIsLoading'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _LatestTournamentsIsLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _LatestTournamentsIsLoading
    implements LatestTournamentsIsLoading {
  const factory _LatestTournamentsIsLoading() = _$_LatestTournamentsIsLoading;
}

class _$MoreLatestTournamentsLoadedTearOff {
  const _$MoreLatestTournamentsLoadedTearOff();

  _MoreLatestTournamentsLoaded call(
      {@required Iterable<Tournament> data, @required int nexPage}) {
    return _MoreLatestTournamentsLoaded(
      data: data,
      nexPage: nexPage,
    );
  }
}

// ignore: unused_element
const $MoreLatestTournamentsLoaded = _$MoreLatestTournamentsLoadedTearOff();

mixin _$MoreLatestTournamentsLoaded {
  Iterable<Tournament> get data;
  int get nexPage;

  $MoreLatestTournamentsLoadedCopyWith<MoreLatestTournamentsLoaded>
      get copyWith;
}

abstract class $MoreLatestTournamentsLoadedCopyWith<$Res> {
  factory $MoreLatestTournamentsLoadedCopyWith(
          MoreLatestTournamentsLoaded value,
          $Res Function(MoreLatestTournamentsLoaded) then) =
      _$MoreLatestTournamentsLoadedCopyWithImpl<$Res>;
  $Res call({Iterable<Tournament> data, int nexPage});
}

class _$MoreLatestTournamentsLoadedCopyWithImpl<$Res>
    implements $MoreLatestTournamentsLoadedCopyWith<$Res> {
  _$MoreLatestTournamentsLoadedCopyWithImpl(this._value, this._then);

  final MoreLatestTournamentsLoaded _value;
  // ignore: unused_field
  final $Res Function(MoreLatestTournamentsLoaded) _then;

  @override
  $Res call({
    Object data = freezed,
    Object nexPage = freezed,
  }) {
    return _then(_value.copyWith(
      data: data == freezed ? _value.data : data as Iterable<Tournament>,
      nexPage: nexPage == freezed ? _value.nexPage : nexPage as int,
    ));
  }
}

abstract class _$MoreLatestTournamentsLoadedCopyWith<$Res>
    implements $MoreLatestTournamentsLoadedCopyWith<$Res> {
  factory _$MoreLatestTournamentsLoadedCopyWith(
          _MoreLatestTournamentsLoaded value,
          $Res Function(_MoreLatestTournamentsLoaded) then) =
      __$MoreLatestTournamentsLoadedCopyWithImpl<$Res>;
  @override
  $Res call({Iterable<Tournament> data, int nexPage});
}

class __$MoreLatestTournamentsLoadedCopyWithImpl<$Res>
    extends _$MoreLatestTournamentsLoadedCopyWithImpl<$Res>
    implements _$MoreLatestTournamentsLoadedCopyWith<$Res> {
  __$MoreLatestTournamentsLoadedCopyWithImpl(
      _MoreLatestTournamentsLoaded _value,
      $Res Function(_MoreLatestTournamentsLoaded) _then)
      : super(_value, (v) => _then(v as _MoreLatestTournamentsLoaded));

  @override
  _MoreLatestTournamentsLoaded get _value =>
      super._value as _MoreLatestTournamentsLoaded;

  @override
  $Res call({
    Object data = freezed,
    Object nexPage = freezed,
  }) {
    return _then(_MoreLatestTournamentsLoaded(
      data: data == freezed ? _value.data : data as Iterable<Tournament>,
      nexPage: nexPage == freezed ? _value.nexPage : nexPage as int,
    ));
  }
}

class _$_MoreLatestTournamentsLoaded
    with DiagnosticableTreeMixin
    implements _MoreLatestTournamentsLoaded {
  const _$_MoreLatestTournamentsLoaded(
      {@required this.data, @required this.nexPage})
      : assert(data != null),
        assert(nexPage != null);

  @override
  final Iterable<Tournament> data;
  @override
  final int nexPage;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MoreLatestTournamentsLoaded(data: $data, nexPage: $nexPage)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'MoreLatestTournamentsLoaded'))
      ..add(DiagnosticsProperty('data', data))
      ..add(DiagnosticsProperty('nexPage', nexPage));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MoreLatestTournamentsLoaded &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.nexPage, nexPage) ||
                const DeepCollectionEquality().equals(other.nexPage, nexPage)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(nexPage);

  @override
  _$MoreLatestTournamentsLoadedCopyWith<_MoreLatestTournamentsLoaded>
      get copyWith => __$MoreLatestTournamentsLoadedCopyWithImpl<
          _MoreLatestTournamentsLoaded>(this, _$identity);
}

abstract class _MoreLatestTournamentsLoaded
    implements MoreLatestTournamentsLoaded {
  const factory _MoreLatestTournamentsLoaded(
      {@required Iterable<Tournament> data,
      @required int nexPage}) = _$_MoreLatestTournamentsLoaded;

  @override
  Iterable<Tournament> get data;
  @override
  int get nexPage;
  @override
  _$MoreLatestTournamentsLoadedCopyWith<_MoreLatestTournamentsLoaded>
      get copyWith;
}

class _$LatestTournamentsIsRefreshingTearOff {
  const _$LatestTournamentsIsRefreshingTearOff();

  _LatestTournamentsIsRefreshing call() {
    return const _LatestTournamentsIsRefreshing();
  }
}

// ignore: unused_element
const $LatestTournamentsIsRefreshing = _$LatestTournamentsIsRefreshingTearOff();

mixin _$LatestTournamentsIsRefreshing {}

abstract class $LatestTournamentsIsRefreshingCopyWith<$Res> {
  factory $LatestTournamentsIsRefreshingCopyWith(
          LatestTournamentsIsRefreshing value,
          $Res Function(LatestTournamentsIsRefreshing) then) =
      _$LatestTournamentsIsRefreshingCopyWithImpl<$Res>;
}

class _$LatestTournamentsIsRefreshingCopyWithImpl<$Res>
    implements $LatestTournamentsIsRefreshingCopyWith<$Res> {
  _$LatestTournamentsIsRefreshingCopyWithImpl(this._value, this._then);

  final LatestTournamentsIsRefreshing _value;
  // ignore: unused_field
  final $Res Function(LatestTournamentsIsRefreshing) _then;
}

abstract class _$LatestTournamentsIsRefreshingCopyWith<$Res> {
  factory _$LatestTournamentsIsRefreshingCopyWith(
          _LatestTournamentsIsRefreshing value,
          $Res Function(_LatestTournamentsIsRefreshing) then) =
      __$LatestTournamentsIsRefreshingCopyWithImpl<$Res>;
}

class __$LatestTournamentsIsRefreshingCopyWithImpl<$Res>
    extends _$LatestTournamentsIsRefreshingCopyWithImpl<$Res>
    implements _$LatestTournamentsIsRefreshingCopyWith<$Res> {
  __$LatestTournamentsIsRefreshingCopyWithImpl(
      _LatestTournamentsIsRefreshing _value,
      $Res Function(_LatestTournamentsIsRefreshing) _then)
      : super(_value, (v) => _then(v as _LatestTournamentsIsRefreshing));

  @override
  _LatestTournamentsIsRefreshing get _value =>
      super._value as _LatestTournamentsIsRefreshing;
}

class _$_LatestTournamentsIsRefreshing
    with DiagnosticableTreeMixin
    implements _LatestTournamentsIsRefreshing {
  const _$_LatestTournamentsIsRefreshing();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LatestTournamentsIsRefreshing()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LatestTournamentsIsRefreshing'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _LatestTournamentsIsRefreshing);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _LatestTournamentsIsRefreshing
    implements LatestTournamentsIsRefreshing {
  const factory _LatestTournamentsIsRefreshing() =
      _$_LatestTournamentsIsRefreshing;
}

class _$LatestTournamentsLoadFailedTearOff {
  const _$LatestTournamentsLoadFailedTearOff();

  _LatestTournamentsLoadFailed call({@required Exception exception}) {
    return _LatestTournamentsLoadFailed(
      exception: exception,
    );
  }
}

// ignore: unused_element
const $LatestTournamentsLoadFailed = _$LatestTournamentsLoadFailedTearOff();

mixin _$LatestTournamentsLoadFailed {
  Exception get exception;

  $LatestTournamentsLoadFailedCopyWith<LatestTournamentsLoadFailed>
      get copyWith;
}

abstract class $LatestTournamentsLoadFailedCopyWith<$Res> {
  factory $LatestTournamentsLoadFailedCopyWith(
          LatestTournamentsLoadFailed value,
          $Res Function(LatestTournamentsLoadFailed) then) =
      _$LatestTournamentsLoadFailedCopyWithImpl<$Res>;
  $Res call({Exception exception});
}

class _$LatestTournamentsLoadFailedCopyWithImpl<$Res>
    implements $LatestTournamentsLoadFailedCopyWith<$Res> {
  _$LatestTournamentsLoadFailedCopyWithImpl(this._value, this._then);

  final LatestTournamentsLoadFailed _value;
  // ignore: unused_field
  final $Res Function(LatestTournamentsLoadFailed) _then;

  @override
  $Res call({
    Object exception = freezed,
  }) {
    return _then(_value.copyWith(
      exception:
          exception == freezed ? _value.exception : exception as Exception,
    ));
  }
}

abstract class _$LatestTournamentsLoadFailedCopyWith<$Res>
    implements $LatestTournamentsLoadFailedCopyWith<$Res> {
  factory _$LatestTournamentsLoadFailedCopyWith(
          _LatestTournamentsLoadFailed value,
          $Res Function(_LatestTournamentsLoadFailed) then) =
      __$LatestTournamentsLoadFailedCopyWithImpl<$Res>;
  @override
  $Res call({Exception exception});
}

class __$LatestTournamentsLoadFailedCopyWithImpl<$Res>
    extends _$LatestTournamentsLoadFailedCopyWithImpl<$Res>
    implements _$LatestTournamentsLoadFailedCopyWith<$Res> {
  __$LatestTournamentsLoadFailedCopyWithImpl(
      _LatestTournamentsLoadFailed _value,
      $Res Function(_LatestTournamentsLoadFailed) _then)
      : super(_value, (v) => _then(v as _LatestTournamentsLoadFailed));

  @override
  _LatestTournamentsLoadFailed get _value =>
      super._value as _LatestTournamentsLoadFailed;

  @override
  $Res call({
    Object exception = freezed,
  }) {
    return _then(_LatestTournamentsLoadFailed(
      exception:
          exception == freezed ? _value.exception : exception as Exception,
    ));
  }
}

class _$_LatestTournamentsLoadFailed
    with DiagnosticableTreeMixin
    implements _LatestTournamentsLoadFailed {
  const _$_LatestTournamentsLoadFailed({@required this.exception})
      : assert(exception != null);

  @override
  final Exception exception;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LatestTournamentsLoadFailed(exception: $exception)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LatestTournamentsLoadFailed'))
      ..add(DiagnosticsProperty('exception', exception));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _LatestTournamentsLoadFailed &&
            (identical(other.exception, exception) ||
                const DeepCollectionEquality()
                    .equals(other.exception, exception)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(exception);

  @override
  _$LatestTournamentsLoadFailedCopyWith<_LatestTournamentsLoadFailed>
      get copyWith => __$LatestTournamentsLoadFailedCopyWithImpl<
          _LatestTournamentsLoadFailed>(this, _$identity);
}

abstract class _LatestTournamentsLoadFailed
    implements LatestTournamentsLoadFailed {
  const factory _LatestTournamentsLoadFailed({@required Exception exception}) =
      _$_LatestTournamentsLoadFailed;

  @override
  Exception get exception;
  @override
  _$LatestTournamentsLoadFailedCopyWith<_LatestTournamentsLoadFailed>
      get copyWith;
}
