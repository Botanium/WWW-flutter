// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'actions.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$SearchTournamentsTearOff {
  const _$SearchTournamentsTearOff();

  _SearchTournaments call() {
    return const _SearchTournaments();
  }
}

// ignore: unused_element
const $SearchTournaments = _$SearchTournamentsTearOff();

mixin _$SearchTournaments {}

abstract class $SearchTournamentsCopyWith<$Res> {
  factory $SearchTournamentsCopyWith(
          SearchTournaments value, $Res Function(SearchTournaments) then) =
      _$SearchTournamentsCopyWithImpl<$Res>;
}

class _$SearchTournamentsCopyWithImpl<$Res>
    implements $SearchTournamentsCopyWith<$Res> {
  _$SearchTournamentsCopyWithImpl(this._value, this._then);

  final SearchTournaments _value;
  // ignore: unused_field
  final $Res Function(SearchTournaments) _then;
}

abstract class _$SearchTournamentsCopyWith<$Res> {
  factory _$SearchTournamentsCopyWith(
          _SearchTournaments value, $Res Function(_SearchTournaments) then) =
      __$SearchTournamentsCopyWithImpl<$Res>;
}

class __$SearchTournamentsCopyWithImpl<$Res>
    extends _$SearchTournamentsCopyWithImpl<$Res>
    implements _$SearchTournamentsCopyWith<$Res> {
  __$SearchTournamentsCopyWithImpl(
      _SearchTournaments _value, $Res Function(_SearchTournaments) _then)
      : super(_value, (v) => _then(v as _SearchTournaments));

  @override
  _SearchTournaments get _value => super._value as _SearchTournaments;
}

class _$_SearchTournaments
    with DiagnosticableTreeMixin
    implements _SearchTournaments {
  const _$_SearchTournaments();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SearchTournaments()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'SearchTournaments'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _SearchTournaments);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _SearchTournaments implements SearchTournaments {
  const factory _SearchTournaments() = _$_SearchTournaments;
}

class _$RepeatFailedSearchTournamentsTearOff {
  const _$RepeatFailedSearchTournamentsTearOff();

  _RepeatFailedSearchTournaments call() {
    return const _RepeatFailedSearchTournaments();
  }
}

// ignore: unused_element
const $RepeatFailedSearchTournaments = _$RepeatFailedSearchTournamentsTearOff();

mixin _$RepeatFailedSearchTournaments {}

abstract class $RepeatFailedSearchTournamentsCopyWith<$Res> {
  factory $RepeatFailedSearchTournamentsCopyWith(
          RepeatFailedSearchTournaments value,
          $Res Function(RepeatFailedSearchTournaments) then) =
      _$RepeatFailedSearchTournamentsCopyWithImpl<$Res>;
}

class _$RepeatFailedSearchTournamentsCopyWithImpl<$Res>
    implements $RepeatFailedSearchTournamentsCopyWith<$Res> {
  _$RepeatFailedSearchTournamentsCopyWithImpl(this._value, this._then);

  final RepeatFailedSearchTournaments _value;
  // ignore: unused_field
  final $Res Function(RepeatFailedSearchTournaments) _then;
}

abstract class _$RepeatFailedSearchTournamentsCopyWith<$Res> {
  factory _$RepeatFailedSearchTournamentsCopyWith(
          _RepeatFailedSearchTournaments value,
          $Res Function(_RepeatFailedSearchTournaments) then) =
      __$RepeatFailedSearchTournamentsCopyWithImpl<$Res>;
}

class __$RepeatFailedSearchTournamentsCopyWithImpl<$Res>
    extends _$RepeatFailedSearchTournamentsCopyWithImpl<$Res>
    implements _$RepeatFailedSearchTournamentsCopyWith<$Res> {
  __$RepeatFailedSearchTournamentsCopyWithImpl(
      _RepeatFailedSearchTournaments _value,
      $Res Function(_RepeatFailedSearchTournaments) _then)
      : super(_value, (v) => _then(v as _RepeatFailedSearchTournaments));

  @override
  _RepeatFailedSearchTournaments get _value =>
      super._value as _RepeatFailedSearchTournaments;
}

class _$_RepeatFailedSearchTournaments
    with DiagnosticableTreeMixin
    implements _RepeatFailedSearchTournaments {
  const _$_RepeatFailedSearchTournaments();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'RepeatFailedSearchTournaments()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'RepeatFailedSearchTournaments'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _RepeatFailedSearchTournaments);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _RepeatFailedSearchTournaments
    implements RepeatFailedSearchTournaments {
  const factory _RepeatFailedSearchTournaments() =
      _$_RepeatFailedSearchTournaments;
}

class _$ClearTournamentsSearchResultsTearOff {
  const _$ClearTournamentsSearchResultsTearOff();

  _ClearTournamentsSearchResults call() {
    return const _ClearTournamentsSearchResults();
  }
}

// ignore: unused_element
const $ClearTournamentsSearchResults = _$ClearTournamentsSearchResultsTearOff();

mixin _$ClearTournamentsSearchResults {}

abstract class $ClearTournamentsSearchResultsCopyWith<$Res> {
  factory $ClearTournamentsSearchResultsCopyWith(
          ClearTournamentsSearchResults value,
          $Res Function(ClearTournamentsSearchResults) then) =
      _$ClearTournamentsSearchResultsCopyWithImpl<$Res>;
}

class _$ClearTournamentsSearchResultsCopyWithImpl<$Res>
    implements $ClearTournamentsSearchResultsCopyWith<$Res> {
  _$ClearTournamentsSearchResultsCopyWithImpl(this._value, this._then);

  final ClearTournamentsSearchResults _value;
  // ignore: unused_field
  final $Res Function(ClearTournamentsSearchResults) _then;
}

abstract class _$ClearTournamentsSearchResultsCopyWith<$Res> {
  factory _$ClearTournamentsSearchResultsCopyWith(
          _ClearTournamentsSearchResults value,
          $Res Function(_ClearTournamentsSearchResults) then) =
      __$ClearTournamentsSearchResultsCopyWithImpl<$Res>;
}

class __$ClearTournamentsSearchResultsCopyWithImpl<$Res>
    extends _$ClearTournamentsSearchResultsCopyWithImpl<$Res>
    implements _$ClearTournamentsSearchResultsCopyWith<$Res> {
  __$ClearTournamentsSearchResultsCopyWithImpl(
      _ClearTournamentsSearchResults _value,
      $Res Function(_ClearTournamentsSearchResults) _then)
      : super(_value, (v) => _then(v as _ClearTournamentsSearchResults));

  @override
  _ClearTournamentsSearchResults get _value =>
      super._value as _ClearTournamentsSearchResults;
}

class _$_ClearTournamentsSearchResults
    with DiagnosticableTreeMixin
    implements _ClearTournamentsSearchResults {
  const _$_ClearTournamentsSearchResults();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ClearTournamentsSearchResults()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ClearTournamentsSearchResults'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ClearTournamentsSearchResults);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _ClearTournamentsSearchResults
    implements ClearTournamentsSearchResults {
  const factory _ClearTournamentsSearchResults() =
      _$_ClearTournamentsSearchResults;
}

class _$TournamentsSearchQueryChangedTearOff {
  const _$TournamentsSearchQueryChangedTearOff();

  _TournamentsSearchQueryChanged call({@required String query}) {
    return _TournamentsSearchQueryChanged(
      query: query,
    );
  }
}

// ignore: unused_element
const $TournamentsSearchQueryChanged = _$TournamentsSearchQueryChangedTearOff();

mixin _$TournamentsSearchQueryChanged {
  String get query;

  $TournamentsSearchQueryChangedCopyWith<TournamentsSearchQueryChanged>
      get copyWith;
}

abstract class $TournamentsSearchQueryChangedCopyWith<$Res> {
  factory $TournamentsSearchQueryChangedCopyWith(
          TournamentsSearchQueryChanged value,
          $Res Function(TournamentsSearchQueryChanged) then) =
      _$TournamentsSearchQueryChangedCopyWithImpl<$Res>;
  $Res call({String query});
}

class _$TournamentsSearchQueryChangedCopyWithImpl<$Res>
    implements $TournamentsSearchQueryChangedCopyWith<$Res> {
  _$TournamentsSearchQueryChangedCopyWithImpl(this._value, this._then);

  final TournamentsSearchQueryChanged _value;
  // ignore: unused_field
  final $Res Function(TournamentsSearchQueryChanged) _then;

  @override
  $Res call({
    Object query = freezed,
  }) {
    return _then(_value.copyWith(
      query: query == freezed ? _value.query : query as String,
    ));
  }
}

abstract class _$TournamentsSearchQueryChangedCopyWith<$Res>
    implements $TournamentsSearchQueryChangedCopyWith<$Res> {
  factory _$TournamentsSearchQueryChangedCopyWith(
          _TournamentsSearchQueryChanged value,
          $Res Function(_TournamentsSearchQueryChanged) then) =
      __$TournamentsSearchQueryChangedCopyWithImpl<$Res>;
  @override
  $Res call({String query});
}

class __$TournamentsSearchQueryChangedCopyWithImpl<$Res>
    extends _$TournamentsSearchQueryChangedCopyWithImpl<$Res>
    implements _$TournamentsSearchQueryChangedCopyWith<$Res> {
  __$TournamentsSearchQueryChangedCopyWithImpl(
      _TournamentsSearchQueryChanged _value,
      $Res Function(_TournamentsSearchQueryChanged) _then)
      : super(_value, (v) => _then(v as _TournamentsSearchQueryChanged));

  @override
  _TournamentsSearchQueryChanged get _value =>
      super._value as _TournamentsSearchQueryChanged;

  @override
  $Res call({
    Object query = freezed,
  }) {
    return _then(_TournamentsSearchQueryChanged(
      query: query == freezed ? _value.query : query as String,
    ));
  }
}

class _$_TournamentsSearchQueryChanged
    with DiagnosticableTreeMixin
    implements _TournamentsSearchQueryChanged {
  const _$_TournamentsSearchQueryChanged({@required this.query})
      : assert(query != null);

  @override
  final String query;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TournamentsSearchQueryChanged(query: $query)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TournamentsSearchQueryChanged'))
      ..add(DiagnosticsProperty('query', query));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TournamentsSearchQueryChanged &&
            (identical(other.query, query) ||
                const DeepCollectionEquality().equals(other.query, query)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(query);

  @override
  _$TournamentsSearchQueryChangedCopyWith<_TournamentsSearchQueryChanged>
      get copyWith => __$TournamentsSearchQueryChangedCopyWithImpl<
          _TournamentsSearchQueryChanged>(this, _$identity);
}

abstract class _TournamentsSearchQueryChanged
    implements TournamentsSearchQueryChanged {
  const factory _TournamentsSearchQueryChanged({@required String query}) =
      _$_TournamentsSearchQueryChanged;

  @override
  String get query;
  @override
  _$TournamentsSearchQueryChangedCopyWith<_TournamentsSearchQueryChanged>
      get copyWith;
}

class _$TournamentsSearchSortingChangedTearOff {
  const _$TournamentsSearchSortingChangedTearOff();

  _TournamentsSearchSortingChanged call({@required Sorting sorting}) {
    return _TournamentsSearchSortingChanged(
      sorting: sorting,
    );
  }
}

// ignore: unused_element
const $TournamentsSearchSortingChanged =
    _$TournamentsSearchSortingChangedTearOff();

mixin _$TournamentsSearchSortingChanged {
  Sorting get sorting;

  $TournamentsSearchSortingChangedCopyWith<TournamentsSearchSortingChanged>
      get copyWith;
}

abstract class $TournamentsSearchSortingChangedCopyWith<$Res> {
  factory $TournamentsSearchSortingChangedCopyWith(
          TournamentsSearchSortingChanged value,
          $Res Function(TournamentsSearchSortingChanged) then) =
      _$TournamentsSearchSortingChangedCopyWithImpl<$Res>;
  $Res call({Sorting sorting});
}

class _$TournamentsSearchSortingChangedCopyWithImpl<$Res>
    implements $TournamentsSearchSortingChangedCopyWith<$Res> {
  _$TournamentsSearchSortingChangedCopyWithImpl(this._value, this._then);

  final TournamentsSearchSortingChanged _value;
  // ignore: unused_field
  final $Res Function(TournamentsSearchSortingChanged) _then;

  @override
  $Res call({
    Object sorting = freezed,
  }) {
    return _then(_value.copyWith(
      sorting: sorting == freezed ? _value.sorting : sorting as Sorting,
    ));
  }
}

abstract class _$TournamentsSearchSortingChangedCopyWith<$Res>
    implements $TournamentsSearchSortingChangedCopyWith<$Res> {
  factory _$TournamentsSearchSortingChangedCopyWith(
          _TournamentsSearchSortingChanged value,
          $Res Function(_TournamentsSearchSortingChanged) then) =
      __$TournamentsSearchSortingChangedCopyWithImpl<$Res>;
  @override
  $Res call({Sorting sorting});
}

class __$TournamentsSearchSortingChangedCopyWithImpl<$Res>
    extends _$TournamentsSearchSortingChangedCopyWithImpl<$Res>
    implements _$TournamentsSearchSortingChangedCopyWith<$Res> {
  __$TournamentsSearchSortingChangedCopyWithImpl(
      _TournamentsSearchSortingChanged _value,
      $Res Function(_TournamentsSearchSortingChanged) _then)
      : super(_value, (v) => _then(v as _TournamentsSearchSortingChanged));

  @override
  _TournamentsSearchSortingChanged get _value =>
      super._value as _TournamentsSearchSortingChanged;

  @override
  $Res call({
    Object sorting = freezed,
  }) {
    return _then(_TournamentsSearchSortingChanged(
      sorting: sorting == freezed ? _value.sorting : sorting as Sorting,
    ));
  }
}

class _$_TournamentsSearchSortingChanged
    with DiagnosticableTreeMixin
    implements _TournamentsSearchSortingChanged {
  const _$_TournamentsSearchSortingChanged({@required this.sorting})
      : assert(sorting != null);

  @override
  final Sorting sorting;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TournamentsSearchSortingChanged(sorting: $sorting)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TournamentsSearchSortingChanged'))
      ..add(DiagnosticsProperty('sorting', sorting));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TournamentsSearchSortingChanged &&
            (identical(other.sorting, sorting) ||
                const DeepCollectionEquality().equals(other.sorting, sorting)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(sorting);

  @override
  _$TournamentsSearchSortingChangedCopyWith<_TournamentsSearchSortingChanged>
      get copyWith => __$TournamentsSearchSortingChangedCopyWithImpl<
          _TournamentsSearchSortingChanged>(this, _$identity);
}

abstract class _TournamentsSearchSortingChanged
    implements TournamentsSearchSortingChanged {
  const factory _TournamentsSearchSortingChanged({@required Sorting sorting}) =
      _$_TournamentsSearchSortingChanged;

  @override
  Sorting get sorting;
  @override
  _$TournamentsSearchSortingChangedCopyWith<_TournamentsSearchSortingChanged>
      get copyWith;
}

class _$TournamentsSearchIsLoadingTearOff {
  const _$TournamentsSearchIsLoadingTearOff();

  _TournamentsSearchIsLoading call() {
    return const _TournamentsSearchIsLoading();
  }
}

// ignore: unused_element
const $TournamentsSearchIsLoading = _$TournamentsSearchIsLoadingTearOff();

mixin _$TournamentsSearchIsLoading {}

abstract class $TournamentsSearchIsLoadingCopyWith<$Res> {
  factory $TournamentsSearchIsLoadingCopyWith(TournamentsSearchIsLoading value,
          $Res Function(TournamentsSearchIsLoading) then) =
      _$TournamentsSearchIsLoadingCopyWithImpl<$Res>;
}

class _$TournamentsSearchIsLoadingCopyWithImpl<$Res>
    implements $TournamentsSearchIsLoadingCopyWith<$Res> {
  _$TournamentsSearchIsLoadingCopyWithImpl(this._value, this._then);

  final TournamentsSearchIsLoading _value;
  // ignore: unused_field
  final $Res Function(TournamentsSearchIsLoading) _then;
}

abstract class _$TournamentsSearchIsLoadingCopyWith<$Res> {
  factory _$TournamentsSearchIsLoadingCopyWith(
          _TournamentsSearchIsLoading value,
          $Res Function(_TournamentsSearchIsLoading) then) =
      __$TournamentsSearchIsLoadingCopyWithImpl<$Res>;
}

class __$TournamentsSearchIsLoadingCopyWithImpl<$Res>
    extends _$TournamentsSearchIsLoadingCopyWithImpl<$Res>
    implements _$TournamentsSearchIsLoadingCopyWith<$Res> {
  __$TournamentsSearchIsLoadingCopyWithImpl(_TournamentsSearchIsLoading _value,
      $Res Function(_TournamentsSearchIsLoading) _then)
      : super(_value, (v) => _then(v as _TournamentsSearchIsLoading));

  @override
  _TournamentsSearchIsLoading get _value =>
      super._value as _TournamentsSearchIsLoading;
}

class _$_TournamentsSearchIsLoading
    with DiagnosticableTreeMixin
    implements _TournamentsSearchIsLoading {
  const _$_TournamentsSearchIsLoading();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TournamentsSearchIsLoading()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'TournamentsSearchIsLoading'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _TournamentsSearchIsLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _TournamentsSearchIsLoading
    implements TournamentsSearchIsLoading {
  const factory _TournamentsSearchIsLoading() = _$_TournamentsSearchIsLoading;
}

class _$TournamentsSearchLoadedTearOff {
  const _$TournamentsSearchLoadedTearOff();

  _TournamentsSearchLoaded call(
      {@required Iterable<Tournament> data, @required int nextPage}) {
    return _TournamentsSearchLoaded(
      data: data,
      nextPage: nextPage,
    );
  }
}

// ignore: unused_element
const $TournamentsSearchLoaded = _$TournamentsSearchLoadedTearOff();

mixin _$TournamentsSearchLoaded {
  Iterable<Tournament> get data;
  int get nextPage;

  $TournamentsSearchLoadedCopyWith<TournamentsSearchLoaded> get copyWith;
}

abstract class $TournamentsSearchLoadedCopyWith<$Res> {
  factory $TournamentsSearchLoadedCopyWith(TournamentsSearchLoaded value,
          $Res Function(TournamentsSearchLoaded) then) =
      _$TournamentsSearchLoadedCopyWithImpl<$Res>;
  $Res call({Iterable<Tournament> data, int nextPage});
}

class _$TournamentsSearchLoadedCopyWithImpl<$Res>
    implements $TournamentsSearchLoadedCopyWith<$Res> {
  _$TournamentsSearchLoadedCopyWithImpl(this._value, this._then);

  final TournamentsSearchLoaded _value;
  // ignore: unused_field
  final $Res Function(TournamentsSearchLoaded) _then;

  @override
  $Res call({
    Object data = freezed,
    Object nextPage = freezed,
  }) {
    return _then(_value.copyWith(
      data: data == freezed ? _value.data : data as Iterable<Tournament>,
      nextPage: nextPage == freezed ? _value.nextPage : nextPage as int,
    ));
  }
}

abstract class _$TournamentsSearchLoadedCopyWith<$Res>
    implements $TournamentsSearchLoadedCopyWith<$Res> {
  factory _$TournamentsSearchLoadedCopyWith(_TournamentsSearchLoaded value,
          $Res Function(_TournamentsSearchLoaded) then) =
      __$TournamentsSearchLoadedCopyWithImpl<$Res>;
  @override
  $Res call({Iterable<Tournament> data, int nextPage});
}

class __$TournamentsSearchLoadedCopyWithImpl<$Res>
    extends _$TournamentsSearchLoadedCopyWithImpl<$Res>
    implements _$TournamentsSearchLoadedCopyWith<$Res> {
  __$TournamentsSearchLoadedCopyWithImpl(_TournamentsSearchLoaded _value,
      $Res Function(_TournamentsSearchLoaded) _then)
      : super(_value, (v) => _then(v as _TournamentsSearchLoaded));

  @override
  _TournamentsSearchLoaded get _value =>
      super._value as _TournamentsSearchLoaded;

  @override
  $Res call({
    Object data = freezed,
    Object nextPage = freezed,
  }) {
    return _then(_TournamentsSearchLoaded(
      data: data == freezed ? _value.data : data as Iterable<Tournament>,
      nextPage: nextPage == freezed ? _value.nextPage : nextPage as int,
    ));
  }
}

class _$_TournamentsSearchLoaded
    with DiagnosticableTreeMixin
    implements _TournamentsSearchLoaded {
  const _$_TournamentsSearchLoaded(
      {@required this.data, @required this.nextPage})
      : assert(data != null),
        assert(nextPage != null);

  @override
  final Iterable<Tournament> data;
  @override
  final int nextPage;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TournamentsSearchLoaded(data: $data, nextPage: $nextPage)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TournamentsSearchLoaded'))
      ..add(DiagnosticsProperty('data', data))
      ..add(DiagnosticsProperty('nextPage', nextPage));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TournamentsSearchLoaded &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.nextPage, nextPage) ||
                const DeepCollectionEquality()
                    .equals(other.nextPage, nextPage)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(nextPage);

  @override
  _$TournamentsSearchLoadedCopyWith<_TournamentsSearchLoaded> get copyWith =>
      __$TournamentsSearchLoadedCopyWithImpl<_TournamentsSearchLoaded>(
          this, _$identity);
}

abstract class _TournamentsSearchLoaded implements TournamentsSearchLoaded {
  const factory _TournamentsSearchLoaded(
      {@required Iterable<Tournament> data,
      @required int nextPage}) = _$_TournamentsSearchLoaded;

  @override
  Iterable<Tournament> get data;
  @override
  int get nextPage;
  @override
  _$TournamentsSearchLoadedCopyWith<_TournamentsSearchLoaded> get copyWith;
}

class _$TournamentsSearchFailedToLoadTearOff {
  const _$TournamentsSearchFailedToLoadTearOff();

  _TournamentsSearchFailedToLoad call({@required Exception exception}) {
    return _TournamentsSearchFailedToLoad(
      exception: exception,
    );
  }
}

// ignore: unused_element
const $TournamentsSearchFailedToLoad = _$TournamentsSearchFailedToLoadTearOff();

mixin _$TournamentsSearchFailedToLoad {
  Exception get exception;

  $TournamentsSearchFailedToLoadCopyWith<TournamentsSearchFailedToLoad>
      get copyWith;
}

abstract class $TournamentsSearchFailedToLoadCopyWith<$Res> {
  factory $TournamentsSearchFailedToLoadCopyWith(
          TournamentsSearchFailedToLoad value,
          $Res Function(TournamentsSearchFailedToLoad) then) =
      _$TournamentsSearchFailedToLoadCopyWithImpl<$Res>;
  $Res call({Exception exception});
}

class _$TournamentsSearchFailedToLoadCopyWithImpl<$Res>
    implements $TournamentsSearchFailedToLoadCopyWith<$Res> {
  _$TournamentsSearchFailedToLoadCopyWithImpl(this._value, this._then);

  final TournamentsSearchFailedToLoad _value;
  // ignore: unused_field
  final $Res Function(TournamentsSearchFailedToLoad) _then;

  @override
  $Res call({
    Object exception = freezed,
  }) {
    return _then(_value.copyWith(
      exception:
          exception == freezed ? _value.exception : exception as Exception,
    ));
  }
}

abstract class _$TournamentsSearchFailedToLoadCopyWith<$Res>
    implements $TournamentsSearchFailedToLoadCopyWith<$Res> {
  factory _$TournamentsSearchFailedToLoadCopyWith(
          _TournamentsSearchFailedToLoad value,
          $Res Function(_TournamentsSearchFailedToLoad) then) =
      __$TournamentsSearchFailedToLoadCopyWithImpl<$Res>;
  @override
  $Res call({Exception exception});
}

class __$TournamentsSearchFailedToLoadCopyWithImpl<$Res>
    extends _$TournamentsSearchFailedToLoadCopyWithImpl<$Res>
    implements _$TournamentsSearchFailedToLoadCopyWith<$Res> {
  __$TournamentsSearchFailedToLoadCopyWithImpl(
      _TournamentsSearchFailedToLoad _value,
      $Res Function(_TournamentsSearchFailedToLoad) _then)
      : super(_value, (v) => _then(v as _TournamentsSearchFailedToLoad));

  @override
  _TournamentsSearchFailedToLoad get _value =>
      super._value as _TournamentsSearchFailedToLoad;

  @override
  $Res call({
    Object exception = freezed,
  }) {
    return _then(_TournamentsSearchFailedToLoad(
      exception:
          exception == freezed ? _value.exception : exception as Exception,
    ));
  }
}

class _$_TournamentsSearchFailedToLoad
    with DiagnosticableTreeMixin
    implements _TournamentsSearchFailedToLoad {
  const _$_TournamentsSearchFailedToLoad({@required this.exception})
      : assert(exception != null);

  @override
  final Exception exception;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TournamentsSearchFailedToLoad(exception: $exception)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TournamentsSearchFailedToLoad'))
      ..add(DiagnosticsProperty('exception', exception));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TournamentsSearchFailedToLoad &&
            (identical(other.exception, exception) ||
                const DeepCollectionEquality()
                    .equals(other.exception, exception)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(exception);

  @override
  _$TournamentsSearchFailedToLoadCopyWith<_TournamentsSearchFailedToLoad>
      get copyWith => __$TournamentsSearchFailedToLoadCopyWithImpl<
          _TournamentsSearchFailedToLoad>(this, _$identity);
}

abstract class _TournamentsSearchFailedToLoad
    implements TournamentsSearchFailedToLoad {
  const factory _TournamentsSearchFailedToLoad(
      {@required Exception exception}) = _$_TournamentsSearchFailedToLoad;

  @override
  Exception get exception;
  @override
  _$TournamentsSearchFailedToLoadCopyWith<_TournamentsSearchFailedToLoad>
      get copyWith;
}

class _$ClearSearchTournamentsExceptionTearOff {
  const _$ClearSearchTournamentsExceptionTearOff();

  _ClearSearchTournamentsException call() {
    return const _ClearSearchTournamentsException();
  }
}

// ignore: unused_element
const $ClearSearchTournamentsException =
    _$ClearSearchTournamentsExceptionTearOff();

mixin _$ClearSearchTournamentsException {}

abstract class $ClearSearchTournamentsExceptionCopyWith<$Res> {
  factory $ClearSearchTournamentsExceptionCopyWith(
          ClearSearchTournamentsException value,
          $Res Function(ClearSearchTournamentsException) then) =
      _$ClearSearchTournamentsExceptionCopyWithImpl<$Res>;
}

class _$ClearSearchTournamentsExceptionCopyWithImpl<$Res>
    implements $ClearSearchTournamentsExceptionCopyWith<$Res> {
  _$ClearSearchTournamentsExceptionCopyWithImpl(this._value, this._then);

  final ClearSearchTournamentsException _value;
  // ignore: unused_field
  final $Res Function(ClearSearchTournamentsException) _then;
}

abstract class _$ClearSearchTournamentsExceptionCopyWith<$Res> {
  factory _$ClearSearchTournamentsExceptionCopyWith(
          _ClearSearchTournamentsException value,
          $Res Function(_ClearSearchTournamentsException) then) =
      __$ClearSearchTournamentsExceptionCopyWithImpl<$Res>;
}

class __$ClearSearchTournamentsExceptionCopyWithImpl<$Res>
    extends _$ClearSearchTournamentsExceptionCopyWithImpl<$Res>
    implements _$ClearSearchTournamentsExceptionCopyWith<$Res> {
  __$ClearSearchTournamentsExceptionCopyWithImpl(
      _ClearSearchTournamentsException _value,
      $Res Function(_ClearSearchTournamentsException) _then)
      : super(_value, (v) => _then(v as _ClearSearchTournamentsException));

  @override
  _ClearSearchTournamentsException get _value =>
      super._value as _ClearSearchTournamentsException;
}

class _$_ClearSearchTournamentsException
    with DiagnosticableTreeMixin
    implements _ClearSearchTournamentsException {
  const _$_ClearSearchTournamentsException();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ClearSearchTournamentsException()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ClearSearchTournamentsException'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ClearSearchTournamentsException);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _ClearSearchTournamentsException
    implements ClearSearchTournamentsException {
  const factory _ClearSearchTournamentsException() =
      _$_ClearSearchTournamentsException;
}
