// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'actions.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$ChangeThemeTearOff {
  const _$ChangeThemeTearOff();

  _ChangeTheme call({@required AppTheme appTheme}) {
    return _ChangeTheme(
      appTheme: appTheme,
    );
  }
}

// ignore: unused_element
const $ChangeTheme = _$ChangeThemeTearOff();

mixin _$ChangeTheme {
  AppTheme get appTheme;

  $ChangeThemeCopyWith<ChangeTheme> get copyWith;
}

abstract class $ChangeThemeCopyWith<$Res> {
  factory $ChangeThemeCopyWith(
          ChangeTheme value, $Res Function(ChangeTheme) then) =
      _$ChangeThemeCopyWithImpl<$Res>;
  $Res call({AppTheme appTheme});
}

class _$ChangeThemeCopyWithImpl<$Res> implements $ChangeThemeCopyWith<$Res> {
  _$ChangeThemeCopyWithImpl(this._value, this._then);

  final ChangeTheme _value;
  // ignore: unused_field
  final $Res Function(ChangeTheme) _then;

  @override
  $Res call({
    Object appTheme = freezed,
  }) {
    return _then(_value.copyWith(
      appTheme: appTheme == freezed ? _value.appTheme : appTheme as AppTheme,
    ));
  }
}

abstract class _$ChangeThemeCopyWith<$Res>
    implements $ChangeThemeCopyWith<$Res> {
  factory _$ChangeThemeCopyWith(
          _ChangeTheme value, $Res Function(_ChangeTheme) then) =
      __$ChangeThemeCopyWithImpl<$Res>;
  @override
  $Res call({AppTheme appTheme});
}

class __$ChangeThemeCopyWithImpl<$Res> extends _$ChangeThemeCopyWithImpl<$Res>
    implements _$ChangeThemeCopyWith<$Res> {
  __$ChangeThemeCopyWithImpl(
      _ChangeTheme _value, $Res Function(_ChangeTheme) _then)
      : super(_value, (v) => _then(v as _ChangeTheme));

  @override
  _ChangeTheme get _value => super._value as _ChangeTheme;

  @override
  $Res call({
    Object appTheme = freezed,
  }) {
    return _then(_ChangeTheme(
      appTheme: appTheme == freezed ? _value.appTheme : appTheme as AppTheme,
    ));
  }
}

class _$_ChangeTheme with DiagnosticableTreeMixin implements _ChangeTheme {
  const _$_ChangeTheme({@required this.appTheme}) : assert(appTheme != null);

  @override
  final AppTheme appTheme;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChangeTheme(appTheme: $appTheme)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ChangeTheme'))
      ..add(DiagnosticsProperty('appTheme', appTheme));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ChangeTheme &&
            (identical(other.appTheme, appTheme) ||
                const DeepCollectionEquality()
                    .equals(other.appTheme, appTheme)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(appTheme);

  @override
  _$ChangeThemeCopyWith<_ChangeTheme> get copyWith =>
      __$ChangeThemeCopyWithImpl<_ChangeTheme>(this, _$identity);
}

abstract class _ChangeTheme implements ChangeTheme {
  const factory _ChangeTheme({@required AppTheme appTheme}) = _$_ChangeTheme;

  @override
  AppTheme get appTheme;
  @override
  _$ChangeThemeCopyWith<_ChangeTheme> get copyWith;
}

class _$ChangeTextScaleTearOff {
  const _$ChangeTextScaleTearOff();

  _ChangeTextScale call({@required TextScale textScale}) {
    return _ChangeTextScale(
      textScale: textScale,
    );
  }
}

// ignore: unused_element
const $ChangeTextScale = _$ChangeTextScaleTearOff();

mixin _$ChangeTextScale {
  TextScale get textScale;

  $ChangeTextScaleCopyWith<ChangeTextScale> get copyWith;
}

abstract class $ChangeTextScaleCopyWith<$Res> {
  factory $ChangeTextScaleCopyWith(
          ChangeTextScale value, $Res Function(ChangeTextScale) then) =
      _$ChangeTextScaleCopyWithImpl<$Res>;
  $Res call({TextScale textScale});
}

class _$ChangeTextScaleCopyWithImpl<$Res>
    implements $ChangeTextScaleCopyWith<$Res> {
  _$ChangeTextScaleCopyWithImpl(this._value, this._then);

  final ChangeTextScale _value;
  // ignore: unused_field
  final $Res Function(ChangeTextScale) _then;

  @override
  $Res call({
    Object textScale = freezed,
  }) {
    return _then(_value.copyWith(
      textScale:
          textScale == freezed ? _value.textScale : textScale as TextScale,
    ));
  }
}

abstract class _$ChangeTextScaleCopyWith<$Res>
    implements $ChangeTextScaleCopyWith<$Res> {
  factory _$ChangeTextScaleCopyWith(
          _ChangeTextScale value, $Res Function(_ChangeTextScale) then) =
      __$ChangeTextScaleCopyWithImpl<$Res>;
  @override
  $Res call({TextScale textScale});
}

class __$ChangeTextScaleCopyWithImpl<$Res>
    extends _$ChangeTextScaleCopyWithImpl<$Res>
    implements _$ChangeTextScaleCopyWith<$Res> {
  __$ChangeTextScaleCopyWithImpl(
      _ChangeTextScale _value, $Res Function(_ChangeTextScale) _then)
      : super(_value, (v) => _then(v as _ChangeTextScale));

  @override
  _ChangeTextScale get _value => super._value as _ChangeTextScale;

  @override
  $Res call({
    Object textScale = freezed,
  }) {
    return _then(_ChangeTextScale(
      textScale:
          textScale == freezed ? _value.textScale : textScale as TextScale,
    ));
  }
}

class _$_ChangeTextScale
    with DiagnosticableTreeMixin
    implements _ChangeTextScale {
  const _$_ChangeTextScale({@required this.textScale})
      : assert(textScale != null);

  @override
  final TextScale textScale;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChangeTextScale(textScale: $textScale)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ChangeTextScale'))
      ..add(DiagnosticsProperty('textScale', textScale));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ChangeTextScale &&
            (identical(other.textScale, textScale) ||
                const DeepCollectionEquality()
                    .equals(other.textScale, textScale)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(textScale);

  @override
  _$ChangeTextScaleCopyWith<_ChangeTextScale> get copyWith =>
      __$ChangeTextScaleCopyWithImpl<_ChangeTextScale>(this, _$identity);
}

abstract class _ChangeTextScale implements ChangeTextScale {
  const factory _ChangeTextScale({@required TextScale textScale}) =
      _$_ChangeTextScale;

  @override
  TextScale get textScale;
  @override
  _$ChangeTextScaleCopyWith<_ChangeTextScale> get copyWith;
}

class _$ChangeNotifyShortTimerExpirationTearOff {
  const _$ChangeNotifyShortTimerExpirationTearOff();

  _ChangeNotifyShortTimerExpiration call({@required bool newValue}) {
    return _ChangeNotifyShortTimerExpiration(
      newValue: newValue,
    );
  }
}

// ignore: unused_element
const $ChangeNotifyShortTimerExpiration =
    _$ChangeNotifyShortTimerExpirationTearOff();

mixin _$ChangeNotifyShortTimerExpiration {
  bool get newValue;

  $ChangeNotifyShortTimerExpirationCopyWith<ChangeNotifyShortTimerExpiration>
      get copyWith;
}

abstract class $ChangeNotifyShortTimerExpirationCopyWith<$Res> {
  factory $ChangeNotifyShortTimerExpirationCopyWith(
          ChangeNotifyShortTimerExpiration value,
          $Res Function(ChangeNotifyShortTimerExpiration) then) =
      _$ChangeNotifyShortTimerExpirationCopyWithImpl<$Res>;
  $Res call({bool newValue});
}

class _$ChangeNotifyShortTimerExpirationCopyWithImpl<$Res>
    implements $ChangeNotifyShortTimerExpirationCopyWith<$Res> {
  _$ChangeNotifyShortTimerExpirationCopyWithImpl(this._value, this._then);

  final ChangeNotifyShortTimerExpiration _value;
  // ignore: unused_field
  final $Res Function(ChangeNotifyShortTimerExpiration) _then;

  @override
  $Res call({
    Object newValue = freezed,
  }) {
    return _then(_value.copyWith(
      newValue: newValue == freezed ? _value.newValue : newValue as bool,
    ));
  }
}

abstract class _$ChangeNotifyShortTimerExpirationCopyWith<$Res>
    implements $ChangeNotifyShortTimerExpirationCopyWith<$Res> {
  factory _$ChangeNotifyShortTimerExpirationCopyWith(
          _ChangeNotifyShortTimerExpiration value,
          $Res Function(_ChangeNotifyShortTimerExpiration) then) =
      __$ChangeNotifyShortTimerExpirationCopyWithImpl<$Res>;
  @override
  $Res call({bool newValue});
}

class __$ChangeNotifyShortTimerExpirationCopyWithImpl<$Res>
    extends _$ChangeNotifyShortTimerExpirationCopyWithImpl<$Res>
    implements _$ChangeNotifyShortTimerExpirationCopyWith<$Res> {
  __$ChangeNotifyShortTimerExpirationCopyWithImpl(
      _ChangeNotifyShortTimerExpiration _value,
      $Res Function(_ChangeNotifyShortTimerExpiration) _then)
      : super(_value, (v) => _then(v as _ChangeNotifyShortTimerExpiration));

  @override
  _ChangeNotifyShortTimerExpiration get _value =>
      super._value as _ChangeNotifyShortTimerExpiration;

  @override
  $Res call({
    Object newValue = freezed,
  }) {
    return _then(_ChangeNotifyShortTimerExpiration(
      newValue: newValue == freezed ? _value.newValue : newValue as bool,
    ));
  }
}

class _$_ChangeNotifyShortTimerExpiration
    with DiagnosticableTreeMixin
    implements _ChangeNotifyShortTimerExpiration {
  const _$_ChangeNotifyShortTimerExpiration({@required this.newValue})
      : assert(newValue != null);

  @override
  final bool newValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChangeNotifyShortTimerExpiration(newValue: $newValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ChangeNotifyShortTimerExpiration'))
      ..add(DiagnosticsProperty('newValue', newValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ChangeNotifyShortTimerExpiration &&
            (identical(other.newValue, newValue) ||
                const DeepCollectionEquality()
                    .equals(other.newValue, newValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(newValue);

  @override
  _$ChangeNotifyShortTimerExpirationCopyWith<_ChangeNotifyShortTimerExpiration>
      get copyWith => __$ChangeNotifyShortTimerExpirationCopyWithImpl<
          _ChangeNotifyShortTimerExpiration>(this, _$identity);
}

abstract class _ChangeNotifyShortTimerExpiration
    implements ChangeNotifyShortTimerExpiration {
  const factory _ChangeNotifyShortTimerExpiration({@required bool newValue}) =
      _$_ChangeNotifyShortTimerExpiration;

  @override
  bool get newValue;
  @override
  _$ChangeNotifyShortTimerExpirationCopyWith<_ChangeNotifyShortTimerExpiration>
      get copyWith;
}

class _$ChangeNotifyLongTimerExpirationTearOff {
  const _$ChangeNotifyLongTimerExpirationTearOff();

  _ChangeNotifyLongTimerExpiration call({@required bool newValue}) {
    return _ChangeNotifyLongTimerExpiration(
      newValue: newValue,
    );
  }
}

// ignore: unused_element
const $ChangeNotifyLongTimerExpiration =
    _$ChangeNotifyLongTimerExpirationTearOff();

mixin _$ChangeNotifyLongTimerExpiration {
  bool get newValue;

  $ChangeNotifyLongTimerExpirationCopyWith<ChangeNotifyLongTimerExpiration>
      get copyWith;
}

abstract class $ChangeNotifyLongTimerExpirationCopyWith<$Res> {
  factory $ChangeNotifyLongTimerExpirationCopyWith(
          ChangeNotifyLongTimerExpiration value,
          $Res Function(ChangeNotifyLongTimerExpiration) then) =
      _$ChangeNotifyLongTimerExpirationCopyWithImpl<$Res>;
  $Res call({bool newValue});
}

class _$ChangeNotifyLongTimerExpirationCopyWithImpl<$Res>
    implements $ChangeNotifyLongTimerExpirationCopyWith<$Res> {
  _$ChangeNotifyLongTimerExpirationCopyWithImpl(this._value, this._then);

  final ChangeNotifyLongTimerExpiration _value;
  // ignore: unused_field
  final $Res Function(ChangeNotifyLongTimerExpiration) _then;

  @override
  $Res call({
    Object newValue = freezed,
  }) {
    return _then(_value.copyWith(
      newValue: newValue == freezed ? _value.newValue : newValue as bool,
    ));
  }
}

abstract class _$ChangeNotifyLongTimerExpirationCopyWith<$Res>
    implements $ChangeNotifyLongTimerExpirationCopyWith<$Res> {
  factory _$ChangeNotifyLongTimerExpirationCopyWith(
          _ChangeNotifyLongTimerExpiration value,
          $Res Function(_ChangeNotifyLongTimerExpiration) then) =
      __$ChangeNotifyLongTimerExpirationCopyWithImpl<$Res>;
  @override
  $Res call({bool newValue});
}

class __$ChangeNotifyLongTimerExpirationCopyWithImpl<$Res>
    extends _$ChangeNotifyLongTimerExpirationCopyWithImpl<$Res>
    implements _$ChangeNotifyLongTimerExpirationCopyWith<$Res> {
  __$ChangeNotifyLongTimerExpirationCopyWithImpl(
      _ChangeNotifyLongTimerExpiration _value,
      $Res Function(_ChangeNotifyLongTimerExpiration) _then)
      : super(_value, (v) => _then(v as _ChangeNotifyLongTimerExpiration));

  @override
  _ChangeNotifyLongTimerExpiration get _value =>
      super._value as _ChangeNotifyLongTimerExpiration;

  @override
  $Res call({
    Object newValue = freezed,
  }) {
    return _then(_ChangeNotifyLongTimerExpiration(
      newValue: newValue == freezed ? _value.newValue : newValue as bool,
    ));
  }
}

class _$_ChangeNotifyLongTimerExpiration
    with DiagnosticableTreeMixin
    implements _ChangeNotifyLongTimerExpiration {
  const _$_ChangeNotifyLongTimerExpiration({@required this.newValue})
      : assert(newValue != null);

  @override
  final bool newValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChangeNotifyLongTimerExpiration(newValue: $newValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ChangeNotifyLongTimerExpiration'))
      ..add(DiagnosticsProperty('newValue', newValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ChangeNotifyLongTimerExpiration &&
            (identical(other.newValue, newValue) ||
                const DeepCollectionEquality()
                    .equals(other.newValue, newValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(newValue);

  @override
  _$ChangeNotifyLongTimerExpirationCopyWith<_ChangeNotifyLongTimerExpiration>
      get copyWith => __$ChangeNotifyLongTimerExpirationCopyWithImpl<
          _ChangeNotifyLongTimerExpiration>(this, _$identity);
}

abstract class _ChangeNotifyLongTimerExpiration
    implements ChangeNotifyLongTimerExpiration {
  const factory _ChangeNotifyLongTimerExpiration({@required bool newValue}) =
      _$_ChangeNotifyLongTimerExpiration;

  @override
  bool get newValue;
  @override
  _$ChangeNotifyLongTimerExpirationCopyWith<_ChangeNotifyLongTimerExpiration>
      get copyWith;
}

class _$ReadSettingsTearOff {
  const _$ReadSettingsTearOff();

  _ReadSettings call() {
    return const _ReadSettings();
  }
}

// ignore: unused_element
const $ReadSettings = _$ReadSettingsTearOff();

mixin _$ReadSettings {}

abstract class $ReadSettingsCopyWith<$Res> {
  factory $ReadSettingsCopyWith(
          ReadSettings value, $Res Function(ReadSettings) then) =
      _$ReadSettingsCopyWithImpl<$Res>;
}

class _$ReadSettingsCopyWithImpl<$Res> implements $ReadSettingsCopyWith<$Res> {
  _$ReadSettingsCopyWithImpl(this._value, this._then);

  final ReadSettings _value;
  // ignore: unused_field
  final $Res Function(ReadSettings) _then;
}

abstract class _$ReadSettingsCopyWith<$Res> {
  factory _$ReadSettingsCopyWith(
          _ReadSettings value, $Res Function(_ReadSettings) then) =
      __$ReadSettingsCopyWithImpl<$Res>;
}

class __$ReadSettingsCopyWithImpl<$Res> extends _$ReadSettingsCopyWithImpl<$Res>
    implements _$ReadSettingsCopyWith<$Res> {
  __$ReadSettingsCopyWithImpl(
      _ReadSettings _value, $Res Function(_ReadSettings) _then)
      : super(_value, (v) => _then(v as _ReadSettings));

  @override
  _ReadSettings get _value => super._value as _ReadSettings;
}

class _$_ReadSettings with DiagnosticableTreeMixin implements _ReadSettings {
  const _$_ReadSettings();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ReadSettings()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'ReadSettings'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ReadSettings);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _ReadSettings implements ReadSettings {
  const factory _ReadSettings() = _$_ReadSettings;
}

class _$SettingsReadTearOff {
  const _$SettingsReadTearOff();

  _SettingsRead call(
      {AppTheme appTheme,
      TextScale textScale,
      bool notifyShortTimerExpiration,
      bool notifyLongTimerExpiration}) {
    return _SettingsRead(
      appTheme: appTheme,
      textScale: textScale,
      notifyShortTimerExpiration: notifyShortTimerExpiration,
      notifyLongTimerExpiration: notifyLongTimerExpiration,
    );
  }
}

// ignore: unused_element
const $SettingsRead = _$SettingsReadTearOff();

mixin _$SettingsRead {
  AppTheme get appTheme;
  TextScale get textScale;
  bool get notifyShortTimerExpiration;
  bool get notifyLongTimerExpiration;

  $SettingsReadCopyWith<SettingsRead> get copyWith;
}

abstract class $SettingsReadCopyWith<$Res> {
  factory $SettingsReadCopyWith(
          SettingsRead value, $Res Function(SettingsRead) then) =
      _$SettingsReadCopyWithImpl<$Res>;
  $Res call(
      {AppTheme appTheme,
      TextScale textScale,
      bool notifyShortTimerExpiration,
      bool notifyLongTimerExpiration});
}

class _$SettingsReadCopyWithImpl<$Res> implements $SettingsReadCopyWith<$Res> {
  _$SettingsReadCopyWithImpl(this._value, this._then);

  final SettingsRead _value;
  // ignore: unused_field
  final $Res Function(SettingsRead) _then;

  @override
  $Res call({
    Object appTheme = freezed,
    Object textScale = freezed,
    Object notifyShortTimerExpiration = freezed,
    Object notifyLongTimerExpiration = freezed,
  }) {
    return _then(_value.copyWith(
      appTheme: appTheme == freezed ? _value.appTheme : appTheme as AppTheme,
      textScale:
          textScale == freezed ? _value.textScale : textScale as TextScale,
      notifyShortTimerExpiration: notifyShortTimerExpiration == freezed
          ? _value.notifyShortTimerExpiration
          : notifyShortTimerExpiration as bool,
      notifyLongTimerExpiration: notifyLongTimerExpiration == freezed
          ? _value.notifyLongTimerExpiration
          : notifyLongTimerExpiration as bool,
    ));
  }
}

abstract class _$SettingsReadCopyWith<$Res>
    implements $SettingsReadCopyWith<$Res> {
  factory _$SettingsReadCopyWith(
          _SettingsRead value, $Res Function(_SettingsRead) then) =
      __$SettingsReadCopyWithImpl<$Res>;
  @override
  $Res call(
      {AppTheme appTheme,
      TextScale textScale,
      bool notifyShortTimerExpiration,
      bool notifyLongTimerExpiration});
}

class __$SettingsReadCopyWithImpl<$Res> extends _$SettingsReadCopyWithImpl<$Res>
    implements _$SettingsReadCopyWith<$Res> {
  __$SettingsReadCopyWithImpl(
      _SettingsRead _value, $Res Function(_SettingsRead) _then)
      : super(_value, (v) => _then(v as _SettingsRead));

  @override
  _SettingsRead get _value => super._value as _SettingsRead;

  @override
  $Res call({
    Object appTheme = freezed,
    Object textScale = freezed,
    Object notifyShortTimerExpiration = freezed,
    Object notifyLongTimerExpiration = freezed,
  }) {
    return _then(_SettingsRead(
      appTheme: appTheme == freezed ? _value.appTheme : appTheme as AppTheme,
      textScale:
          textScale == freezed ? _value.textScale : textScale as TextScale,
      notifyShortTimerExpiration: notifyShortTimerExpiration == freezed
          ? _value.notifyShortTimerExpiration
          : notifyShortTimerExpiration as bool,
      notifyLongTimerExpiration: notifyLongTimerExpiration == freezed
          ? _value.notifyLongTimerExpiration
          : notifyLongTimerExpiration as bool,
    ));
  }
}

class _$_SettingsRead with DiagnosticableTreeMixin implements _SettingsRead {
  const _$_SettingsRead(
      {this.appTheme,
      this.textScale,
      this.notifyShortTimerExpiration,
      this.notifyLongTimerExpiration});

  @override
  final AppTheme appTheme;
  @override
  final TextScale textScale;
  @override
  final bool notifyShortTimerExpiration;
  @override
  final bool notifyLongTimerExpiration;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SettingsRead(appTheme: $appTheme, textScale: $textScale, notifyShortTimerExpiration: $notifyShortTimerExpiration, notifyLongTimerExpiration: $notifyLongTimerExpiration)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SettingsRead'))
      ..add(DiagnosticsProperty('appTheme', appTheme))
      ..add(DiagnosticsProperty('textScale', textScale))
      ..add(DiagnosticsProperty(
          'notifyShortTimerExpiration', notifyShortTimerExpiration))
      ..add(DiagnosticsProperty(
          'notifyLongTimerExpiration', notifyLongTimerExpiration));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SettingsRead &&
            (identical(other.appTheme, appTheme) ||
                const DeepCollectionEquality()
                    .equals(other.appTheme, appTheme)) &&
            (identical(other.textScale, textScale) ||
                const DeepCollectionEquality()
                    .equals(other.textScale, textScale)) &&
            (identical(other.notifyShortTimerExpiration,
                    notifyShortTimerExpiration) ||
                const DeepCollectionEquality().equals(
                    other.notifyShortTimerExpiration,
                    notifyShortTimerExpiration)) &&
            (identical(other.notifyLongTimerExpiration,
                    notifyLongTimerExpiration) ||
                const DeepCollectionEquality().equals(
                    other.notifyLongTimerExpiration,
                    notifyLongTimerExpiration)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(appTheme) ^
      const DeepCollectionEquality().hash(textScale) ^
      const DeepCollectionEquality().hash(notifyShortTimerExpiration) ^
      const DeepCollectionEquality().hash(notifyLongTimerExpiration);

  @override
  _$SettingsReadCopyWith<_SettingsRead> get copyWith =>
      __$SettingsReadCopyWithImpl<_SettingsRead>(this, _$identity);
}

abstract class _SettingsRead implements SettingsRead {
  const factory _SettingsRead(
      {AppTheme appTheme,
      TextScale textScale,
      bool notifyShortTimerExpiration,
      bool notifyLongTimerExpiration}) = _$_SettingsRead;

  @override
  AppTheme get appTheme;
  @override
  TextScale get textScale;
  @override
  bool get notifyShortTimerExpiration;
  @override
  bool get notifyLongTimerExpiration;
  @override
  _$SettingsReadCopyWith<_SettingsRead> get copyWith;
}
