// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'actions.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$StartTimerTearOff {
  const _$StartTimerTearOff();

  _StartTimer call() {
    return const _StartTimer();
  }
}

// ignore: unused_element
const $StartTimer = _$StartTimerTearOff();

mixin _$StartTimer {}

abstract class $StartTimerCopyWith<$Res> {
  factory $StartTimerCopyWith(
          StartTimer value, $Res Function(StartTimer) then) =
      _$StartTimerCopyWithImpl<$Res>;
}

class _$StartTimerCopyWithImpl<$Res> implements $StartTimerCopyWith<$Res> {
  _$StartTimerCopyWithImpl(this._value, this._then);

  final StartTimer _value;
  // ignore: unused_field
  final $Res Function(StartTimer) _then;
}

abstract class _$StartTimerCopyWith<$Res> {
  factory _$StartTimerCopyWith(
          _StartTimer value, $Res Function(_StartTimer) then) =
      __$StartTimerCopyWithImpl<$Res>;
}

class __$StartTimerCopyWithImpl<$Res> extends _$StartTimerCopyWithImpl<$Res>
    implements _$StartTimerCopyWith<$Res> {
  __$StartTimerCopyWithImpl(
      _StartTimer _value, $Res Function(_StartTimer) _then)
      : super(_value, (v) => _then(v as _StartTimer));

  @override
  _StartTimer get _value => super._value as _StartTimer;
}

class _$_StartTimer with DiagnosticableTreeMixin implements _StartTimer {
  const _$_StartTimer();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StartTimer()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'StartTimer'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _StartTimer);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _StartTimer implements StartTimer {
  const factory _StartTimer() = _$_StartTimer;
}

class _$StopTimerTearOff {
  const _$StopTimerTearOff();

  _StopTimer call() {
    return const _StopTimer();
  }
}

// ignore: unused_element
const $StopTimer = _$StopTimerTearOff();

mixin _$StopTimer {}

abstract class $StopTimerCopyWith<$Res> {
  factory $StopTimerCopyWith(StopTimer value, $Res Function(StopTimer) then) =
      _$StopTimerCopyWithImpl<$Res>;
}

class _$StopTimerCopyWithImpl<$Res> implements $StopTimerCopyWith<$Res> {
  _$StopTimerCopyWithImpl(this._value, this._then);

  final StopTimer _value;
  // ignore: unused_field
  final $Res Function(StopTimer) _then;
}

abstract class _$StopTimerCopyWith<$Res> {
  factory _$StopTimerCopyWith(
          _StopTimer value, $Res Function(_StopTimer) then) =
      __$StopTimerCopyWithImpl<$Res>;
}

class __$StopTimerCopyWithImpl<$Res> extends _$StopTimerCopyWithImpl<$Res>
    implements _$StopTimerCopyWith<$Res> {
  __$StopTimerCopyWithImpl(_StopTimer _value, $Res Function(_StopTimer) _then)
      : super(_value, (v) => _then(v as _StopTimer));

  @override
  _StopTimer get _value => super._value as _StopTimer;
}

class _$_StopTimer with DiagnosticableTreeMixin implements _StopTimer {
  const _$_StopTimer();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StopTimer()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'StopTimer'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _StopTimer);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _StopTimer implements StopTimer {
  const factory _StopTimer() = _$_StopTimer;
}

class _$ResetTimerTearOff {
  const _$ResetTimerTearOff();

  _ResetTimer call() {
    return const _ResetTimer();
  }
}

// ignore: unused_element
const $ResetTimer = _$ResetTimerTearOff();

mixin _$ResetTimer {}

abstract class $ResetTimerCopyWith<$Res> {
  factory $ResetTimerCopyWith(
          ResetTimer value, $Res Function(ResetTimer) then) =
      _$ResetTimerCopyWithImpl<$Res>;
}

class _$ResetTimerCopyWithImpl<$Res> implements $ResetTimerCopyWith<$Res> {
  _$ResetTimerCopyWithImpl(this._value, this._then);

  final ResetTimer _value;
  // ignore: unused_field
  final $Res Function(ResetTimer) _then;
}

abstract class _$ResetTimerCopyWith<$Res> {
  factory _$ResetTimerCopyWith(
          _ResetTimer value, $Res Function(_ResetTimer) then) =
      __$ResetTimerCopyWithImpl<$Res>;
}

class __$ResetTimerCopyWithImpl<$Res> extends _$ResetTimerCopyWithImpl<$Res>
    implements _$ResetTimerCopyWith<$Res> {
  __$ResetTimerCopyWithImpl(
      _ResetTimer _value, $Res Function(_ResetTimer) _then)
      : super(_value, (v) => _then(v as _ResetTimer));

  @override
  _ResetTimer get _value => super._value as _ResetTimer;
}

class _$_ResetTimer with DiagnosticableTreeMixin implements _ResetTimer {
  const _$_ResetTimer();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ResetTimer()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'ResetTimer'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ResetTimer);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _ResetTimer implements ResetTimer {
  const factory _ResetTimer() = _$_ResetTimer;
}

class _$ChangeTimerTypeTearOff {
  const _$ChangeTimerTypeTearOff();

  _ChangeTimerType call({@required TimerType newValue}) {
    return _ChangeTimerType(
      newValue: newValue,
    );
  }
}

// ignore: unused_element
const $ChangeTimerType = _$ChangeTimerTypeTearOff();

mixin _$ChangeTimerType {
  TimerType get newValue;

  $ChangeTimerTypeCopyWith<ChangeTimerType> get copyWith;
}

abstract class $ChangeTimerTypeCopyWith<$Res> {
  factory $ChangeTimerTypeCopyWith(
          ChangeTimerType value, $Res Function(ChangeTimerType) then) =
      _$ChangeTimerTypeCopyWithImpl<$Res>;
  $Res call({TimerType newValue});
}

class _$ChangeTimerTypeCopyWithImpl<$Res>
    implements $ChangeTimerTypeCopyWith<$Res> {
  _$ChangeTimerTypeCopyWithImpl(this._value, this._then);

  final ChangeTimerType _value;
  // ignore: unused_field
  final $Res Function(ChangeTimerType) _then;

  @override
  $Res call({
    Object newValue = freezed,
  }) {
    return _then(_value.copyWith(
      newValue: newValue == freezed ? _value.newValue : newValue as TimerType,
    ));
  }
}

abstract class _$ChangeTimerTypeCopyWith<$Res>
    implements $ChangeTimerTypeCopyWith<$Res> {
  factory _$ChangeTimerTypeCopyWith(
          _ChangeTimerType value, $Res Function(_ChangeTimerType) then) =
      __$ChangeTimerTypeCopyWithImpl<$Res>;
  @override
  $Res call({TimerType newValue});
}

class __$ChangeTimerTypeCopyWithImpl<$Res>
    extends _$ChangeTimerTypeCopyWithImpl<$Res>
    implements _$ChangeTimerTypeCopyWith<$Res> {
  __$ChangeTimerTypeCopyWithImpl(
      _ChangeTimerType _value, $Res Function(_ChangeTimerType) _then)
      : super(_value, (v) => _then(v as _ChangeTimerType));

  @override
  _ChangeTimerType get _value => super._value as _ChangeTimerType;

  @override
  $Res call({
    Object newValue = freezed,
  }) {
    return _then(_ChangeTimerType(
      newValue: newValue == freezed ? _value.newValue : newValue as TimerType,
    ));
  }
}

class _$_ChangeTimerType
    with DiagnosticableTreeMixin
    implements _ChangeTimerType {
  const _$_ChangeTimerType({@required this.newValue})
      : assert(newValue != null);

  @override
  final TimerType newValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChangeTimerType(newValue: $newValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ChangeTimerType'))
      ..add(DiagnosticsProperty('newValue', newValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ChangeTimerType &&
            (identical(other.newValue, newValue) ||
                const DeepCollectionEquality()
                    .equals(other.newValue, newValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(newValue);

  @override
  _$ChangeTimerTypeCopyWith<_ChangeTimerType> get copyWith =>
      __$ChangeTimerTypeCopyWithImpl<_ChangeTimerType>(this, _$identity);
}

abstract class _ChangeTimerType implements ChangeTimerType {
  const factory _ChangeTimerType({@required TimerType newValue}) =
      _$_ChangeTimerType;

  @override
  TimerType get newValue;
  @override
  _$ChangeTimerTypeCopyWith<_ChangeTimerType> get copyWith;
}

class _$UpdateTimeValueTearOff {
  const _$UpdateTimeValueTearOff();

  _UpdateTimeValue call({@required int newValue}) {
    return _UpdateTimeValue(
      newValue: newValue,
    );
  }
}

// ignore: unused_element
const $UpdateTimeValue = _$UpdateTimeValueTearOff();

mixin _$UpdateTimeValue {
  int get newValue;

  $UpdateTimeValueCopyWith<UpdateTimeValue> get copyWith;
}

abstract class $UpdateTimeValueCopyWith<$Res> {
  factory $UpdateTimeValueCopyWith(
          UpdateTimeValue value, $Res Function(UpdateTimeValue) then) =
      _$UpdateTimeValueCopyWithImpl<$Res>;
  $Res call({int newValue});
}

class _$UpdateTimeValueCopyWithImpl<$Res>
    implements $UpdateTimeValueCopyWith<$Res> {
  _$UpdateTimeValueCopyWithImpl(this._value, this._then);

  final UpdateTimeValue _value;
  // ignore: unused_field
  final $Res Function(UpdateTimeValue) _then;

  @override
  $Res call({
    Object newValue = freezed,
  }) {
    return _then(_value.copyWith(
      newValue: newValue == freezed ? _value.newValue : newValue as int,
    ));
  }
}

abstract class _$UpdateTimeValueCopyWith<$Res>
    implements $UpdateTimeValueCopyWith<$Res> {
  factory _$UpdateTimeValueCopyWith(
          _UpdateTimeValue value, $Res Function(_UpdateTimeValue) then) =
      __$UpdateTimeValueCopyWithImpl<$Res>;
  @override
  $Res call({int newValue});
}

class __$UpdateTimeValueCopyWithImpl<$Res>
    extends _$UpdateTimeValueCopyWithImpl<$Res>
    implements _$UpdateTimeValueCopyWith<$Res> {
  __$UpdateTimeValueCopyWithImpl(
      _UpdateTimeValue _value, $Res Function(_UpdateTimeValue) _then)
      : super(_value, (v) => _then(v as _UpdateTimeValue));

  @override
  _UpdateTimeValue get _value => super._value as _UpdateTimeValue;

  @override
  $Res call({
    Object newValue = freezed,
  }) {
    return _then(_UpdateTimeValue(
      newValue: newValue == freezed ? _value.newValue : newValue as int,
    ));
  }
}

class _$_UpdateTimeValue
    with DiagnosticableTreeMixin
    implements _UpdateTimeValue {
  const _$_UpdateTimeValue({@required this.newValue})
      : assert(newValue != null);

  @override
  final int newValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'UpdateTimeValue(newValue: $newValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'UpdateTimeValue'))
      ..add(DiagnosticsProperty('newValue', newValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _UpdateTimeValue &&
            (identical(other.newValue, newValue) ||
                const DeepCollectionEquality()
                    .equals(other.newValue, newValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(newValue);

  @override
  _$UpdateTimeValueCopyWith<_UpdateTimeValue> get copyWith =>
      __$UpdateTimeValueCopyWithImpl<_UpdateTimeValue>(this, _$identity);
}

abstract class _UpdateTimeValue implements UpdateTimeValue {
  const factory _UpdateTimeValue({@required int newValue}) = _$_UpdateTimeValue;

  @override
  int get newValue;
  @override
  _$UpdateTimeValueCopyWith<_UpdateTimeValue> get copyWith;
}

class _$UpdateIsRunningValueTearOff {
  const _$UpdateIsRunningValueTearOff();

  _UpdateIsRunningValue call({@required bool newValue}) {
    return _UpdateIsRunningValue(
      newValue: newValue,
    );
  }
}

// ignore: unused_element
const $UpdateIsRunningValue = _$UpdateIsRunningValueTearOff();

mixin _$UpdateIsRunningValue {
  bool get newValue;

  $UpdateIsRunningValueCopyWith<UpdateIsRunningValue> get copyWith;
}

abstract class $UpdateIsRunningValueCopyWith<$Res> {
  factory $UpdateIsRunningValueCopyWith(UpdateIsRunningValue value,
          $Res Function(UpdateIsRunningValue) then) =
      _$UpdateIsRunningValueCopyWithImpl<$Res>;
  $Res call({bool newValue});
}

class _$UpdateIsRunningValueCopyWithImpl<$Res>
    implements $UpdateIsRunningValueCopyWith<$Res> {
  _$UpdateIsRunningValueCopyWithImpl(this._value, this._then);

  final UpdateIsRunningValue _value;
  // ignore: unused_field
  final $Res Function(UpdateIsRunningValue) _then;

  @override
  $Res call({
    Object newValue = freezed,
  }) {
    return _then(_value.copyWith(
      newValue: newValue == freezed ? _value.newValue : newValue as bool,
    ));
  }
}

abstract class _$UpdateIsRunningValueCopyWith<$Res>
    implements $UpdateIsRunningValueCopyWith<$Res> {
  factory _$UpdateIsRunningValueCopyWith(_UpdateIsRunningValue value,
          $Res Function(_UpdateIsRunningValue) then) =
      __$UpdateIsRunningValueCopyWithImpl<$Res>;
  @override
  $Res call({bool newValue});
}

class __$UpdateIsRunningValueCopyWithImpl<$Res>
    extends _$UpdateIsRunningValueCopyWithImpl<$Res>
    implements _$UpdateIsRunningValueCopyWith<$Res> {
  __$UpdateIsRunningValueCopyWithImpl(
      _UpdateIsRunningValue _value, $Res Function(_UpdateIsRunningValue) _then)
      : super(_value, (v) => _then(v as _UpdateIsRunningValue));

  @override
  _UpdateIsRunningValue get _value => super._value as _UpdateIsRunningValue;

  @override
  $Res call({
    Object newValue = freezed,
  }) {
    return _then(_UpdateIsRunningValue(
      newValue: newValue == freezed ? _value.newValue : newValue as bool,
    ));
  }
}

class _$_UpdateIsRunningValue
    with DiagnosticableTreeMixin
    implements _UpdateIsRunningValue {
  const _$_UpdateIsRunningValue({@required this.newValue})
      : assert(newValue != null);

  @override
  final bool newValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'UpdateIsRunningValue(newValue: $newValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'UpdateIsRunningValue'))
      ..add(DiagnosticsProperty('newValue', newValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _UpdateIsRunningValue &&
            (identical(other.newValue, newValue) ||
                const DeepCollectionEquality()
                    .equals(other.newValue, newValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(newValue);

  @override
  _$UpdateIsRunningValueCopyWith<_UpdateIsRunningValue> get copyWith =>
      __$UpdateIsRunningValueCopyWithImpl<_UpdateIsRunningValue>(
          this, _$identity);
}

abstract class _UpdateIsRunningValue implements UpdateIsRunningValue {
  const factory _UpdateIsRunningValue({@required bool newValue}) =
      _$_UpdateIsRunningValue;

  @override
  bool get newValue;
  @override
  _$UpdateIsRunningValueCopyWith<_UpdateIsRunningValue> get copyWith;
}

class _$NotifyExpirationTearOff {
  const _$NotifyExpirationTearOff();

  _NotifyExpiration call() {
    return const _NotifyExpiration();
  }
}

// ignore: unused_element
const $NotifyExpiration = _$NotifyExpirationTearOff();

mixin _$NotifyExpiration {}

abstract class $NotifyExpirationCopyWith<$Res> {
  factory $NotifyExpirationCopyWith(
          NotifyExpiration value, $Res Function(NotifyExpiration) then) =
      _$NotifyExpirationCopyWithImpl<$Res>;
}

class _$NotifyExpirationCopyWithImpl<$Res>
    implements $NotifyExpirationCopyWith<$Res> {
  _$NotifyExpirationCopyWithImpl(this._value, this._then);

  final NotifyExpiration _value;
  // ignore: unused_field
  final $Res Function(NotifyExpiration) _then;
}

abstract class _$NotifyExpirationCopyWith<$Res> {
  factory _$NotifyExpirationCopyWith(
          _NotifyExpiration value, $Res Function(_NotifyExpiration) then) =
      __$NotifyExpirationCopyWithImpl<$Res>;
}

class __$NotifyExpirationCopyWithImpl<$Res>
    extends _$NotifyExpirationCopyWithImpl<$Res>
    implements _$NotifyExpirationCopyWith<$Res> {
  __$NotifyExpirationCopyWithImpl(
      _NotifyExpiration _value, $Res Function(_NotifyExpiration) _then)
      : super(_value, (v) => _then(v as _NotifyExpiration));

  @override
  _NotifyExpiration get _value => super._value as _NotifyExpiration;
}

class _$_NotifyExpiration
    with DiagnosticableTreeMixin
    implements _NotifyExpiration {
  const _$_NotifyExpiration();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'NotifyExpiration()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'NotifyExpiration'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _NotifyExpiration);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _NotifyExpiration implements NotifyExpiration {
  const factory _NotifyExpiration() = _$_NotifyExpiration;
}
