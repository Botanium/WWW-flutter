// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'actions.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$OpenTournamentsTreeTearOff {
  const _$OpenTournamentsTreeTearOff();

  _OpenTournamentsTree call({TournamentsTreeInfo info}) {
    return _OpenTournamentsTree(
      info: info,
    );
  }
}

// ignore: unused_element
const $OpenTournamentsTree = _$OpenTournamentsTreeTearOff();

mixin _$OpenTournamentsTree {
  TournamentsTreeInfo get info;

  $OpenTournamentsTreeCopyWith<OpenTournamentsTree> get copyWith;
}

abstract class $OpenTournamentsTreeCopyWith<$Res> {
  factory $OpenTournamentsTreeCopyWith(
          OpenTournamentsTree value, $Res Function(OpenTournamentsTree) then) =
      _$OpenTournamentsTreeCopyWithImpl<$Res>;
  $Res call({TournamentsTreeInfo info});

  $TournamentsTreeInfoCopyWith<$Res> get info;
}

class _$OpenTournamentsTreeCopyWithImpl<$Res>
    implements $OpenTournamentsTreeCopyWith<$Res> {
  _$OpenTournamentsTreeCopyWithImpl(this._value, this._then);

  final OpenTournamentsTree _value;
  // ignore: unused_field
  final $Res Function(OpenTournamentsTree) _then;

  @override
  $Res call({
    Object info = freezed,
  }) {
    return _then(_value.copyWith(
      info: info == freezed ? _value.info : info as TournamentsTreeInfo,
    ));
  }

  @override
  $TournamentsTreeInfoCopyWith<$Res> get info {
    if (_value.info == null) {
      return null;
    }
    return $TournamentsTreeInfoCopyWith<$Res>(_value.info, (value) {
      return _then(_value.copyWith(info: value));
    });
  }
}

abstract class _$OpenTournamentsTreeCopyWith<$Res>
    implements $OpenTournamentsTreeCopyWith<$Res> {
  factory _$OpenTournamentsTreeCopyWith(_OpenTournamentsTree value,
          $Res Function(_OpenTournamentsTree) then) =
      __$OpenTournamentsTreeCopyWithImpl<$Res>;
  @override
  $Res call({TournamentsTreeInfo info});

  @override
  $TournamentsTreeInfoCopyWith<$Res> get info;
}

class __$OpenTournamentsTreeCopyWithImpl<$Res>
    extends _$OpenTournamentsTreeCopyWithImpl<$Res>
    implements _$OpenTournamentsTreeCopyWith<$Res> {
  __$OpenTournamentsTreeCopyWithImpl(
      _OpenTournamentsTree _value, $Res Function(_OpenTournamentsTree) _then)
      : super(_value, (v) => _then(v as _OpenTournamentsTree));

  @override
  _OpenTournamentsTree get _value => super._value as _OpenTournamentsTree;

  @override
  $Res call({
    Object info = freezed,
  }) {
    return _then(_OpenTournamentsTree(
      info: info == freezed ? _value.info : info as TournamentsTreeInfo,
    ));
  }
}

class _$_OpenTournamentsTree
    with DiagnosticableTreeMixin
    implements _OpenTournamentsTree {
  const _$_OpenTournamentsTree({this.info});

  @override
  final TournamentsTreeInfo info;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'OpenTournamentsTree(info: $info)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'OpenTournamentsTree'))
      ..add(DiagnosticsProperty('info', info));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _OpenTournamentsTree &&
            (identical(other.info, info) ||
                const DeepCollectionEquality().equals(other.info, info)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(info);

  @override
  _$OpenTournamentsTreeCopyWith<_OpenTournamentsTree> get copyWith =>
      __$OpenTournamentsTreeCopyWithImpl<_OpenTournamentsTree>(
          this, _$identity);
}

abstract class _OpenTournamentsTree implements OpenTournamentsTree {
  const factory _OpenTournamentsTree({TournamentsTreeInfo info}) =
      _$_OpenTournamentsTree;

  @override
  TournamentsTreeInfo get info;
  @override
  _$OpenTournamentsTreeCopyWith<_OpenTournamentsTree> get copyWith;
}

class _$SetTournamentsSubTreeTearOff {
  const _$SetTournamentsSubTreeTearOff();

  _SetTournamentsSubTree call({TournamentsTreeInfo info}) {
    return _SetTournamentsSubTree(
      info: info,
    );
  }
}

// ignore: unused_element
const $SetTournamentsSubTree = _$SetTournamentsSubTreeTearOff();

mixin _$SetTournamentsSubTree {
  TournamentsTreeInfo get info;

  $SetTournamentsSubTreeCopyWith<SetTournamentsSubTree> get copyWith;
}

abstract class $SetTournamentsSubTreeCopyWith<$Res> {
  factory $SetTournamentsSubTreeCopyWith(SetTournamentsSubTree value,
          $Res Function(SetTournamentsSubTree) then) =
      _$SetTournamentsSubTreeCopyWithImpl<$Res>;
  $Res call({TournamentsTreeInfo info});

  $TournamentsTreeInfoCopyWith<$Res> get info;
}

class _$SetTournamentsSubTreeCopyWithImpl<$Res>
    implements $SetTournamentsSubTreeCopyWith<$Res> {
  _$SetTournamentsSubTreeCopyWithImpl(this._value, this._then);

  final SetTournamentsSubTree _value;
  // ignore: unused_field
  final $Res Function(SetTournamentsSubTree) _then;

  @override
  $Res call({
    Object info = freezed,
  }) {
    return _then(_value.copyWith(
      info: info == freezed ? _value.info : info as TournamentsTreeInfo,
    ));
  }

  @override
  $TournamentsTreeInfoCopyWith<$Res> get info {
    if (_value.info == null) {
      return null;
    }
    return $TournamentsTreeInfoCopyWith<$Res>(_value.info, (value) {
      return _then(_value.copyWith(info: value));
    });
  }
}

abstract class _$SetTournamentsSubTreeCopyWith<$Res>
    implements $SetTournamentsSubTreeCopyWith<$Res> {
  factory _$SetTournamentsSubTreeCopyWith(_SetTournamentsSubTree value,
          $Res Function(_SetTournamentsSubTree) then) =
      __$SetTournamentsSubTreeCopyWithImpl<$Res>;
  @override
  $Res call({TournamentsTreeInfo info});

  @override
  $TournamentsTreeInfoCopyWith<$Res> get info;
}

class __$SetTournamentsSubTreeCopyWithImpl<$Res>
    extends _$SetTournamentsSubTreeCopyWithImpl<$Res>
    implements _$SetTournamentsSubTreeCopyWith<$Res> {
  __$SetTournamentsSubTreeCopyWithImpl(_SetTournamentsSubTree _value,
      $Res Function(_SetTournamentsSubTree) _then)
      : super(_value, (v) => _then(v as _SetTournamentsSubTree));

  @override
  _SetTournamentsSubTree get _value => super._value as _SetTournamentsSubTree;

  @override
  $Res call({
    Object info = freezed,
  }) {
    return _then(_SetTournamentsSubTree(
      info: info == freezed ? _value.info : info as TournamentsTreeInfo,
    ));
  }
}

class _$_SetTournamentsSubTree
    with DiagnosticableTreeMixin
    implements _SetTournamentsSubTree {
  const _$_SetTournamentsSubTree({this.info});

  @override
  final TournamentsTreeInfo info;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SetTournamentsSubTree(info: $info)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SetTournamentsSubTree'))
      ..add(DiagnosticsProperty('info', info));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SetTournamentsSubTree &&
            (identical(other.info, info) ||
                const DeepCollectionEquality().equals(other.info, info)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(info);

  @override
  _$SetTournamentsSubTreeCopyWith<_SetTournamentsSubTree> get copyWith =>
      __$SetTournamentsSubTreeCopyWithImpl<_SetTournamentsSubTree>(
          this, _$identity);
}

abstract class _SetTournamentsSubTree implements SetTournamentsSubTree {
  const factory _SetTournamentsSubTree({TournamentsTreeInfo info}) =
      _$_SetTournamentsSubTree;

  @override
  TournamentsTreeInfo get info;
  @override
  _$SetTournamentsSubTreeCopyWith<_SetTournamentsSubTree> get copyWith;
}

class _$LoadTournamentsTreeTearOff {
  const _$LoadTournamentsTreeTearOff();

  _LoadTournamentsTree call({@required TournamentsTreeInfo info}) {
    return _LoadTournamentsTree(
      info: info,
    );
  }
}

// ignore: unused_element
const $LoadTournamentsTree = _$LoadTournamentsTreeTearOff();

mixin _$LoadTournamentsTree {
  TournamentsTreeInfo get info;

  $LoadTournamentsTreeCopyWith<LoadTournamentsTree> get copyWith;
}

abstract class $LoadTournamentsTreeCopyWith<$Res> {
  factory $LoadTournamentsTreeCopyWith(
          LoadTournamentsTree value, $Res Function(LoadTournamentsTree) then) =
      _$LoadTournamentsTreeCopyWithImpl<$Res>;
  $Res call({TournamentsTreeInfo info});

  $TournamentsTreeInfoCopyWith<$Res> get info;
}

class _$LoadTournamentsTreeCopyWithImpl<$Res>
    implements $LoadTournamentsTreeCopyWith<$Res> {
  _$LoadTournamentsTreeCopyWithImpl(this._value, this._then);

  final LoadTournamentsTree _value;
  // ignore: unused_field
  final $Res Function(LoadTournamentsTree) _then;

  @override
  $Res call({
    Object info = freezed,
  }) {
    return _then(_value.copyWith(
      info: info == freezed ? _value.info : info as TournamentsTreeInfo,
    ));
  }

  @override
  $TournamentsTreeInfoCopyWith<$Res> get info {
    if (_value.info == null) {
      return null;
    }
    return $TournamentsTreeInfoCopyWith<$Res>(_value.info, (value) {
      return _then(_value.copyWith(info: value));
    });
  }
}

abstract class _$LoadTournamentsTreeCopyWith<$Res>
    implements $LoadTournamentsTreeCopyWith<$Res> {
  factory _$LoadTournamentsTreeCopyWith(_LoadTournamentsTree value,
          $Res Function(_LoadTournamentsTree) then) =
      __$LoadTournamentsTreeCopyWithImpl<$Res>;
  @override
  $Res call({TournamentsTreeInfo info});

  @override
  $TournamentsTreeInfoCopyWith<$Res> get info;
}

class __$LoadTournamentsTreeCopyWithImpl<$Res>
    extends _$LoadTournamentsTreeCopyWithImpl<$Res>
    implements _$LoadTournamentsTreeCopyWith<$Res> {
  __$LoadTournamentsTreeCopyWithImpl(
      _LoadTournamentsTree _value, $Res Function(_LoadTournamentsTree) _then)
      : super(_value, (v) => _then(v as _LoadTournamentsTree));

  @override
  _LoadTournamentsTree get _value => super._value as _LoadTournamentsTree;

  @override
  $Res call({
    Object info = freezed,
  }) {
    return _then(_LoadTournamentsTree(
      info: info == freezed ? _value.info : info as TournamentsTreeInfo,
    ));
  }
}

class _$_LoadTournamentsTree
    with DiagnosticableTreeMixin
    implements _LoadTournamentsTree {
  const _$_LoadTournamentsTree({@required this.info}) : assert(info != null);

  @override
  final TournamentsTreeInfo info;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoadTournamentsTree(info: $info)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LoadTournamentsTree'))
      ..add(DiagnosticsProperty('info', info));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _LoadTournamentsTree &&
            (identical(other.info, info) ||
                const DeepCollectionEquality().equals(other.info, info)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(info);

  @override
  _$LoadTournamentsTreeCopyWith<_LoadTournamentsTree> get copyWith =>
      __$LoadTournamentsTreeCopyWithImpl<_LoadTournamentsTree>(
          this, _$identity);
}

abstract class _LoadTournamentsTree implements LoadTournamentsTree {
  const factory _LoadTournamentsTree({@required TournamentsTreeInfo info}) =
      _$_LoadTournamentsTree;

  @override
  TournamentsTreeInfo get info;
  @override
  _$LoadTournamentsTreeCopyWith<_LoadTournamentsTree> get copyWith;
}

class _$TournamentsTreeIsLoadingTearOff {
  const _$TournamentsTreeIsLoadingTearOff();

  _TournamentsTreeIsLoading call({@required TournamentsTreeInfo info}) {
    return _TournamentsTreeIsLoading(
      info: info,
    );
  }
}

// ignore: unused_element
const $TournamentsTreeIsLoading = _$TournamentsTreeIsLoadingTearOff();

mixin _$TournamentsTreeIsLoading {
  TournamentsTreeInfo get info;

  $TournamentsTreeIsLoadingCopyWith<TournamentsTreeIsLoading> get copyWith;
}

abstract class $TournamentsTreeIsLoadingCopyWith<$Res> {
  factory $TournamentsTreeIsLoadingCopyWith(TournamentsTreeIsLoading value,
          $Res Function(TournamentsTreeIsLoading) then) =
      _$TournamentsTreeIsLoadingCopyWithImpl<$Res>;
  $Res call({TournamentsTreeInfo info});

  $TournamentsTreeInfoCopyWith<$Res> get info;
}

class _$TournamentsTreeIsLoadingCopyWithImpl<$Res>
    implements $TournamentsTreeIsLoadingCopyWith<$Res> {
  _$TournamentsTreeIsLoadingCopyWithImpl(this._value, this._then);

  final TournamentsTreeIsLoading _value;
  // ignore: unused_field
  final $Res Function(TournamentsTreeIsLoading) _then;

  @override
  $Res call({
    Object info = freezed,
  }) {
    return _then(_value.copyWith(
      info: info == freezed ? _value.info : info as TournamentsTreeInfo,
    ));
  }

  @override
  $TournamentsTreeInfoCopyWith<$Res> get info {
    if (_value.info == null) {
      return null;
    }
    return $TournamentsTreeInfoCopyWith<$Res>(_value.info, (value) {
      return _then(_value.copyWith(info: value));
    });
  }
}

abstract class _$TournamentsTreeIsLoadingCopyWith<$Res>
    implements $TournamentsTreeIsLoadingCopyWith<$Res> {
  factory _$TournamentsTreeIsLoadingCopyWith(_TournamentsTreeIsLoading value,
          $Res Function(_TournamentsTreeIsLoading) then) =
      __$TournamentsTreeIsLoadingCopyWithImpl<$Res>;
  @override
  $Res call({TournamentsTreeInfo info});

  @override
  $TournamentsTreeInfoCopyWith<$Res> get info;
}

class __$TournamentsTreeIsLoadingCopyWithImpl<$Res>
    extends _$TournamentsTreeIsLoadingCopyWithImpl<$Res>
    implements _$TournamentsTreeIsLoadingCopyWith<$Res> {
  __$TournamentsTreeIsLoadingCopyWithImpl(_TournamentsTreeIsLoading _value,
      $Res Function(_TournamentsTreeIsLoading) _then)
      : super(_value, (v) => _then(v as _TournamentsTreeIsLoading));

  @override
  _TournamentsTreeIsLoading get _value =>
      super._value as _TournamentsTreeIsLoading;

  @override
  $Res call({
    Object info = freezed,
  }) {
    return _then(_TournamentsTreeIsLoading(
      info: info == freezed ? _value.info : info as TournamentsTreeInfo,
    ));
  }
}

class _$_TournamentsTreeIsLoading
    with DiagnosticableTreeMixin
    implements _TournamentsTreeIsLoading {
  const _$_TournamentsTreeIsLoading({@required this.info})
      : assert(info != null);

  @override
  final TournamentsTreeInfo info;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TournamentsTreeIsLoading(info: $info)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TournamentsTreeIsLoading'))
      ..add(DiagnosticsProperty('info', info));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TournamentsTreeIsLoading &&
            (identical(other.info, info) ||
                const DeepCollectionEquality().equals(other.info, info)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(info);

  @override
  _$TournamentsTreeIsLoadingCopyWith<_TournamentsTreeIsLoading> get copyWith =>
      __$TournamentsTreeIsLoadingCopyWithImpl<_TournamentsTreeIsLoading>(
          this, _$identity);
}

abstract class _TournamentsTreeIsLoading implements TournamentsTreeIsLoading {
  const factory _TournamentsTreeIsLoading(
      {@required TournamentsTreeInfo info}) = _$_TournamentsTreeIsLoading;

  @override
  TournamentsTreeInfo get info;
  @override
  _$TournamentsTreeIsLoadingCopyWith<_TournamentsTreeIsLoading> get copyWith;
}

class _$TournamentsTreeFailedLoadingTearOff {
  const _$TournamentsTreeFailedLoadingTearOff();

  _TournamentsTreeFailedLoading call(
      {@required TournamentsTreeInfo info, @required Exception exception}) {
    return _TournamentsTreeFailedLoading(
      info: info,
      exception: exception,
    );
  }
}

// ignore: unused_element
const $TournamentsTreeFailedLoading = _$TournamentsTreeFailedLoadingTearOff();

mixin _$TournamentsTreeFailedLoading {
  TournamentsTreeInfo get info;
  Exception get exception;

  $TournamentsTreeFailedLoadingCopyWith<TournamentsTreeFailedLoading>
      get copyWith;
}

abstract class $TournamentsTreeFailedLoadingCopyWith<$Res> {
  factory $TournamentsTreeFailedLoadingCopyWith(
          TournamentsTreeFailedLoading value,
          $Res Function(TournamentsTreeFailedLoading) then) =
      _$TournamentsTreeFailedLoadingCopyWithImpl<$Res>;
  $Res call({TournamentsTreeInfo info, Exception exception});

  $TournamentsTreeInfoCopyWith<$Res> get info;
}

class _$TournamentsTreeFailedLoadingCopyWithImpl<$Res>
    implements $TournamentsTreeFailedLoadingCopyWith<$Res> {
  _$TournamentsTreeFailedLoadingCopyWithImpl(this._value, this._then);

  final TournamentsTreeFailedLoading _value;
  // ignore: unused_field
  final $Res Function(TournamentsTreeFailedLoading) _then;

  @override
  $Res call({
    Object info = freezed,
    Object exception = freezed,
  }) {
    return _then(_value.copyWith(
      info: info == freezed ? _value.info : info as TournamentsTreeInfo,
      exception:
          exception == freezed ? _value.exception : exception as Exception,
    ));
  }

  @override
  $TournamentsTreeInfoCopyWith<$Res> get info {
    if (_value.info == null) {
      return null;
    }
    return $TournamentsTreeInfoCopyWith<$Res>(_value.info, (value) {
      return _then(_value.copyWith(info: value));
    });
  }
}

abstract class _$TournamentsTreeFailedLoadingCopyWith<$Res>
    implements $TournamentsTreeFailedLoadingCopyWith<$Res> {
  factory _$TournamentsTreeFailedLoadingCopyWith(
          _TournamentsTreeFailedLoading value,
          $Res Function(_TournamentsTreeFailedLoading) then) =
      __$TournamentsTreeFailedLoadingCopyWithImpl<$Res>;
  @override
  $Res call({TournamentsTreeInfo info, Exception exception});

  @override
  $TournamentsTreeInfoCopyWith<$Res> get info;
}

class __$TournamentsTreeFailedLoadingCopyWithImpl<$Res>
    extends _$TournamentsTreeFailedLoadingCopyWithImpl<$Res>
    implements _$TournamentsTreeFailedLoadingCopyWith<$Res> {
  __$TournamentsTreeFailedLoadingCopyWithImpl(
      _TournamentsTreeFailedLoading _value,
      $Res Function(_TournamentsTreeFailedLoading) _then)
      : super(_value, (v) => _then(v as _TournamentsTreeFailedLoading));

  @override
  _TournamentsTreeFailedLoading get _value =>
      super._value as _TournamentsTreeFailedLoading;

  @override
  $Res call({
    Object info = freezed,
    Object exception = freezed,
  }) {
    return _then(_TournamentsTreeFailedLoading(
      info: info == freezed ? _value.info : info as TournamentsTreeInfo,
      exception:
          exception == freezed ? _value.exception : exception as Exception,
    ));
  }
}

class _$_TournamentsTreeFailedLoading
    with DiagnosticableTreeMixin
    implements _TournamentsTreeFailedLoading {
  const _$_TournamentsTreeFailedLoading(
      {@required this.info, @required this.exception})
      : assert(info != null),
        assert(exception != null);

  @override
  final TournamentsTreeInfo info;
  @override
  final Exception exception;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TournamentsTreeFailedLoading(info: $info, exception: $exception)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TournamentsTreeFailedLoading'))
      ..add(DiagnosticsProperty('info', info))
      ..add(DiagnosticsProperty('exception', exception));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TournamentsTreeFailedLoading &&
            (identical(other.info, info) ||
                const DeepCollectionEquality().equals(other.info, info)) &&
            (identical(other.exception, exception) ||
                const DeepCollectionEquality()
                    .equals(other.exception, exception)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(info) ^
      const DeepCollectionEquality().hash(exception);

  @override
  _$TournamentsTreeFailedLoadingCopyWith<_TournamentsTreeFailedLoading>
      get copyWith => __$TournamentsTreeFailedLoadingCopyWithImpl<
          _TournamentsTreeFailedLoading>(this, _$identity);
}

abstract class _TournamentsTreeFailedLoading
    implements TournamentsTreeFailedLoading {
  const factory _TournamentsTreeFailedLoading(
      {@required TournamentsTreeInfo info,
      @required Exception exception}) = _$_TournamentsTreeFailedLoading;

  @override
  TournamentsTreeInfo get info;
  @override
  Exception get exception;
  @override
  _$TournamentsTreeFailedLoadingCopyWith<_TournamentsTreeFailedLoading>
      get copyWith;
}

class _$TournamentsTreeLoadedTearOff {
  const _$TournamentsTreeLoadedTearOff();

  _TournamentsTreeLoaded call({@required TournamentsTree tree}) {
    return _TournamentsTreeLoaded(
      tree: tree,
    );
  }
}

// ignore: unused_element
const $TournamentsTreeLoaded = _$TournamentsTreeLoadedTearOff();

mixin _$TournamentsTreeLoaded {
  TournamentsTree get tree;

  $TournamentsTreeLoadedCopyWith<TournamentsTreeLoaded> get copyWith;
}

abstract class $TournamentsTreeLoadedCopyWith<$Res> {
  factory $TournamentsTreeLoadedCopyWith(TournamentsTreeLoaded value,
          $Res Function(TournamentsTreeLoaded) then) =
      _$TournamentsTreeLoadedCopyWithImpl<$Res>;
  $Res call({TournamentsTree tree});

  $TournamentsTreeCopyWith<$Res> get tree;
}

class _$TournamentsTreeLoadedCopyWithImpl<$Res>
    implements $TournamentsTreeLoadedCopyWith<$Res> {
  _$TournamentsTreeLoadedCopyWithImpl(this._value, this._then);

  final TournamentsTreeLoaded _value;
  // ignore: unused_field
  final $Res Function(TournamentsTreeLoaded) _then;

  @override
  $Res call({
    Object tree = freezed,
  }) {
    return _then(_value.copyWith(
      tree: tree == freezed ? _value.tree : tree as TournamentsTree,
    ));
  }

  @override
  $TournamentsTreeCopyWith<$Res> get tree {
    if (_value.tree == null) {
      return null;
    }
    return $TournamentsTreeCopyWith<$Res>(_value.tree, (value) {
      return _then(_value.copyWith(tree: value));
    });
  }
}

abstract class _$TournamentsTreeLoadedCopyWith<$Res>
    implements $TournamentsTreeLoadedCopyWith<$Res> {
  factory _$TournamentsTreeLoadedCopyWith(_TournamentsTreeLoaded value,
          $Res Function(_TournamentsTreeLoaded) then) =
      __$TournamentsTreeLoadedCopyWithImpl<$Res>;
  @override
  $Res call({TournamentsTree tree});

  @override
  $TournamentsTreeCopyWith<$Res> get tree;
}

class __$TournamentsTreeLoadedCopyWithImpl<$Res>
    extends _$TournamentsTreeLoadedCopyWithImpl<$Res>
    implements _$TournamentsTreeLoadedCopyWith<$Res> {
  __$TournamentsTreeLoadedCopyWithImpl(_TournamentsTreeLoaded _value,
      $Res Function(_TournamentsTreeLoaded) _then)
      : super(_value, (v) => _then(v as _TournamentsTreeLoaded));

  @override
  _TournamentsTreeLoaded get _value => super._value as _TournamentsTreeLoaded;

  @override
  $Res call({
    Object tree = freezed,
  }) {
    return _then(_TournamentsTreeLoaded(
      tree: tree == freezed ? _value.tree : tree as TournamentsTree,
    ));
  }
}

class _$_TournamentsTreeLoaded
    with DiagnosticableTreeMixin
    implements _TournamentsTreeLoaded {
  const _$_TournamentsTreeLoaded({@required this.tree}) : assert(tree != null);

  @override
  final TournamentsTree tree;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TournamentsTreeLoaded(tree: $tree)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TournamentsTreeLoaded'))
      ..add(DiagnosticsProperty('tree', tree));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TournamentsTreeLoaded &&
            (identical(other.tree, tree) ||
                const DeepCollectionEquality().equals(other.tree, tree)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(tree);

  @override
  _$TournamentsTreeLoadedCopyWith<_TournamentsTreeLoaded> get copyWith =>
      __$TournamentsTreeLoadedCopyWithImpl<_TournamentsTreeLoaded>(
          this, _$identity);
}

abstract class _TournamentsTreeLoaded implements TournamentsTreeLoaded {
  const factory _TournamentsTreeLoaded({@required TournamentsTree tree}) =
      _$_TournamentsTreeLoaded;

  @override
  TournamentsTree get tree;
  @override
  _$TournamentsTreeLoadedCopyWith<_TournamentsTreeLoaded> get copyWith;
}
