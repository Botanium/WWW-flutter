// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'actions.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$LoadTournamentsTreeTearOff {
  const _$LoadTournamentsTreeTearOff();

  _LoadTournamentsTree call({@required String rootId}) {
    return _LoadTournamentsTree(
      rootId: rootId,
    );
  }
}

// ignore: unused_element
const $LoadTournamentsTree = _$LoadTournamentsTreeTearOff();

mixin _$LoadTournamentsTree {
  String get rootId;

  $LoadTournamentsTreeCopyWith<LoadTournamentsTree> get copyWith;
}

abstract class $LoadTournamentsTreeCopyWith<$Res> {
  factory $LoadTournamentsTreeCopyWith(
          LoadTournamentsTree value, $Res Function(LoadTournamentsTree) then) =
      _$LoadTournamentsTreeCopyWithImpl<$Res>;
  $Res call({String rootId});
}

class _$LoadTournamentsTreeCopyWithImpl<$Res>
    implements $LoadTournamentsTreeCopyWith<$Res> {
  _$LoadTournamentsTreeCopyWithImpl(this._value, this._then);

  final LoadTournamentsTree _value;
  // ignore: unused_field
  final $Res Function(LoadTournamentsTree) _then;

  @override
  $Res call({
    Object rootId = freezed,
  }) {
    return _then(_value.copyWith(
      rootId: rootId == freezed ? _value.rootId : rootId as String,
    ));
  }
}

abstract class _$LoadTournamentsTreeCopyWith<$Res>
    implements $LoadTournamentsTreeCopyWith<$Res> {
  factory _$LoadTournamentsTreeCopyWith(_LoadTournamentsTree value,
          $Res Function(_LoadTournamentsTree) then) =
      __$LoadTournamentsTreeCopyWithImpl<$Res>;
  @override
  $Res call({String rootId});
}

class __$LoadTournamentsTreeCopyWithImpl<$Res>
    extends _$LoadTournamentsTreeCopyWithImpl<$Res>
    implements _$LoadTournamentsTreeCopyWith<$Res> {
  __$LoadTournamentsTreeCopyWithImpl(
      _LoadTournamentsTree _value, $Res Function(_LoadTournamentsTree) _then)
      : super(_value, (v) => _then(v as _LoadTournamentsTree));

  @override
  _LoadTournamentsTree get _value => super._value as _LoadTournamentsTree;

  @override
  $Res call({
    Object rootId = freezed,
  }) {
    return _then(_LoadTournamentsTree(
      rootId: rootId == freezed ? _value.rootId : rootId as String,
    ));
  }
}

class _$_LoadTournamentsTree
    with DiagnosticableTreeMixin
    implements _LoadTournamentsTree {
  const _$_LoadTournamentsTree({@required this.rootId})
      : assert(rootId != null);

  @override
  final String rootId;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LoadTournamentsTree(rootId: $rootId)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LoadTournamentsTree'))
      ..add(DiagnosticsProperty('rootId', rootId));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _LoadTournamentsTree &&
            (identical(other.rootId, rootId) ||
                const DeepCollectionEquality().equals(other.rootId, rootId)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(rootId);

  @override
  _$LoadTournamentsTreeCopyWith<_LoadTournamentsTree> get copyWith =>
      __$LoadTournamentsTreeCopyWithImpl<_LoadTournamentsTree>(
          this, _$identity);
}

abstract class _LoadTournamentsTree implements LoadTournamentsTree {
  const factory _LoadTournamentsTree({@required String rootId}) =
      _$_LoadTournamentsTree;

  @override
  String get rootId;
  @override
  _$LoadTournamentsTreeCopyWith<_LoadTournamentsTree> get copyWith;
}

class _$TournamentsTreeIsLoadingTearOff {
  const _$TournamentsTreeIsLoadingTearOff();

  _TournamentsTreeIsLoading call({@required String rootId}) {
    return _TournamentsTreeIsLoading(
      rootId: rootId,
    );
  }
}

// ignore: unused_element
const $TournamentsTreeIsLoading = _$TournamentsTreeIsLoadingTearOff();

mixin _$TournamentsTreeIsLoading {
  String get rootId;

  $TournamentsTreeIsLoadingCopyWith<TournamentsTreeIsLoading> get copyWith;
}

abstract class $TournamentsTreeIsLoadingCopyWith<$Res> {
  factory $TournamentsTreeIsLoadingCopyWith(TournamentsTreeIsLoading value,
          $Res Function(TournamentsTreeIsLoading) then) =
      _$TournamentsTreeIsLoadingCopyWithImpl<$Res>;
  $Res call({String rootId});
}

class _$TournamentsTreeIsLoadingCopyWithImpl<$Res>
    implements $TournamentsTreeIsLoadingCopyWith<$Res> {
  _$TournamentsTreeIsLoadingCopyWithImpl(this._value, this._then);

  final TournamentsTreeIsLoading _value;
  // ignore: unused_field
  final $Res Function(TournamentsTreeIsLoading) _then;

  @override
  $Res call({
    Object rootId = freezed,
  }) {
    return _then(_value.copyWith(
      rootId: rootId == freezed ? _value.rootId : rootId as String,
    ));
  }
}

abstract class _$TournamentsTreeIsLoadingCopyWith<$Res>
    implements $TournamentsTreeIsLoadingCopyWith<$Res> {
  factory _$TournamentsTreeIsLoadingCopyWith(_TournamentsTreeIsLoading value,
          $Res Function(_TournamentsTreeIsLoading) then) =
      __$TournamentsTreeIsLoadingCopyWithImpl<$Res>;
  @override
  $Res call({String rootId});
}

class __$TournamentsTreeIsLoadingCopyWithImpl<$Res>
    extends _$TournamentsTreeIsLoadingCopyWithImpl<$Res>
    implements _$TournamentsTreeIsLoadingCopyWith<$Res> {
  __$TournamentsTreeIsLoadingCopyWithImpl(_TournamentsTreeIsLoading _value,
      $Res Function(_TournamentsTreeIsLoading) _then)
      : super(_value, (v) => _then(v as _TournamentsTreeIsLoading));

  @override
  _TournamentsTreeIsLoading get _value =>
      super._value as _TournamentsTreeIsLoading;

  @override
  $Res call({
    Object rootId = freezed,
  }) {
    return _then(_TournamentsTreeIsLoading(
      rootId: rootId == freezed ? _value.rootId : rootId as String,
    ));
  }
}

class _$_TournamentsTreeIsLoading
    with DiagnosticableTreeMixin
    implements _TournamentsTreeIsLoading {
  const _$_TournamentsTreeIsLoading({@required this.rootId})
      : assert(rootId != null);

  @override
  final String rootId;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TournamentsTreeIsLoading(rootId: $rootId)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TournamentsTreeIsLoading'))
      ..add(DiagnosticsProperty('rootId', rootId));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TournamentsTreeIsLoading &&
            (identical(other.rootId, rootId) ||
                const DeepCollectionEquality().equals(other.rootId, rootId)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(rootId);

  @override
  _$TournamentsTreeIsLoadingCopyWith<_TournamentsTreeIsLoading> get copyWith =>
      __$TournamentsTreeIsLoadingCopyWithImpl<_TournamentsTreeIsLoading>(
          this, _$identity);
}

abstract class _TournamentsTreeIsLoading implements TournamentsTreeIsLoading {
  const factory _TournamentsTreeIsLoading({@required String rootId}) =
      _$_TournamentsTreeIsLoading;

  @override
  String get rootId;
  @override
  _$TournamentsTreeIsLoadingCopyWith<_TournamentsTreeIsLoading> get copyWith;
}

class _$TournamentsTreeFailedLoadingTearOff {
  const _$TournamentsTreeFailedLoadingTearOff();

  _TournamentsTreeFailedLoading call(
      {@required String rootId, @required Exception exception}) {
    return _TournamentsTreeFailedLoading(
      rootId: rootId,
      exception: exception,
    );
  }
}

// ignore: unused_element
const $TournamentsTreeFailedLoading = _$TournamentsTreeFailedLoadingTearOff();

mixin _$TournamentsTreeFailedLoading {
  String get rootId;
  Exception get exception;

  $TournamentsTreeFailedLoadingCopyWith<TournamentsTreeFailedLoading>
      get copyWith;
}

abstract class $TournamentsTreeFailedLoadingCopyWith<$Res> {
  factory $TournamentsTreeFailedLoadingCopyWith(
          TournamentsTreeFailedLoading value,
          $Res Function(TournamentsTreeFailedLoading) then) =
      _$TournamentsTreeFailedLoadingCopyWithImpl<$Res>;
  $Res call({String rootId, Exception exception});
}

class _$TournamentsTreeFailedLoadingCopyWithImpl<$Res>
    implements $TournamentsTreeFailedLoadingCopyWith<$Res> {
  _$TournamentsTreeFailedLoadingCopyWithImpl(this._value, this._then);

  final TournamentsTreeFailedLoading _value;
  // ignore: unused_field
  final $Res Function(TournamentsTreeFailedLoading) _then;

  @override
  $Res call({
    Object rootId = freezed,
    Object exception = freezed,
  }) {
    return _then(_value.copyWith(
      rootId: rootId == freezed ? _value.rootId : rootId as String,
      exception:
          exception == freezed ? _value.exception : exception as Exception,
    ));
  }
}

abstract class _$TournamentsTreeFailedLoadingCopyWith<$Res>
    implements $TournamentsTreeFailedLoadingCopyWith<$Res> {
  factory _$TournamentsTreeFailedLoadingCopyWith(
          _TournamentsTreeFailedLoading value,
          $Res Function(_TournamentsTreeFailedLoading) then) =
      __$TournamentsTreeFailedLoadingCopyWithImpl<$Res>;
  @override
  $Res call({String rootId, Exception exception});
}

class __$TournamentsTreeFailedLoadingCopyWithImpl<$Res>
    extends _$TournamentsTreeFailedLoadingCopyWithImpl<$Res>
    implements _$TournamentsTreeFailedLoadingCopyWith<$Res> {
  __$TournamentsTreeFailedLoadingCopyWithImpl(
      _TournamentsTreeFailedLoading _value,
      $Res Function(_TournamentsTreeFailedLoading) _then)
      : super(_value, (v) => _then(v as _TournamentsTreeFailedLoading));

  @override
  _TournamentsTreeFailedLoading get _value =>
      super._value as _TournamentsTreeFailedLoading;

  @override
  $Res call({
    Object rootId = freezed,
    Object exception = freezed,
  }) {
    return _then(_TournamentsTreeFailedLoading(
      rootId: rootId == freezed ? _value.rootId : rootId as String,
      exception:
          exception == freezed ? _value.exception : exception as Exception,
    ));
  }
}

class _$_TournamentsTreeFailedLoading
    with DiagnosticableTreeMixin
    implements _TournamentsTreeFailedLoading {
  const _$_TournamentsTreeFailedLoading(
      {@required this.rootId, @required this.exception})
      : assert(rootId != null),
        assert(exception != null);

  @override
  final String rootId;
  @override
  final Exception exception;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TournamentsTreeFailedLoading(rootId: $rootId, exception: $exception)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TournamentsTreeFailedLoading'))
      ..add(DiagnosticsProperty('rootId', rootId))
      ..add(DiagnosticsProperty('exception', exception));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TournamentsTreeFailedLoading &&
            (identical(other.rootId, rootId) ||
                const DeepCollectionEquality().equals(other.rootId, rootId)) &&
            (identical(other.exception, exception) ||
                const DeepCollectionEquality()
                    .equals(other.exception, exception)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(rootId) ^
      const DeepCollectionEquality().hash(exception);

  @override
  _$TournamentsTreeFailedLoadingCopyWith<_TournamentsTreeFailedLoading>
      get copyWith => __$TournamentsTreeFailedLoadingCopyWithImpl<
          _TournamentsTreeFailedLoading>(this, _$identity);
}

abstract class _TournamentsTreeFailedLoading
    implements TournamentsTreeFailedLoading {
  const factory _TournamentsTreeFailedLoading(
      {@required String rootId,
      @required Exception exception}) = _$_TournamentsTreeFailedLoading;

  @override
  String get rootId;
  @override
  Exception get exception;
  @override
  _$TournamentsTreeFailedLoadingCopyWith<_TournamentsTreeFailedLoading>
      get copyWith;
}

class _$TournamentsTreeLoadedTearOff {
  const _$TournamentsTreeLoadedTearOff();

  _TournamentsTreeLoaded call(
      {@required String rootId, @required TournamentsTree tree}) {
    return _TournamentsTreeLoaded(
      rootId: rootId,
      tree: tree,
    );
  }
}

// ignore: unused_element
const $TournamentsTreeLoaded = _$TournamentsTreeLoadedTearOff();

mixin _$TournamentsTreeLoaded {
  String get rootId;
  TournamentsTree get tree;

  $TournamentsTreeLoadedCopyWith<TournamentsTreeLoaded> get copyWith;
}

abstract class $TournamentsTreeLoadedCopyWith<$Res> {
  factory $TournamentsTreeLoadedCopyWith(TournamentsTreeLoaded value,
          $Res Function(TournamentsTreeLoaded) then) =
      _$TournamentsTreeLoadedCopyWithImpl<$Res>;
  $Res call({String rootId, TournamentsTree tree});
}

class _$TournamentsTreeLoadedCopyWithImpl<$Res>
    implements $TournamentsTreeLoadedCopyWith<$Res> {
  _$TournamentsTreeLoadedCopyWithImpl(this._value, this._then);

  final TournamentsTreeLoaded _value;
  // ignore: unused_field
  final $Res Function(TournamentsTreeLoaded) _then;

  @override
  $Res call({
    Object rootId = freezed,
    Object tree = freezed,
  }) {
    return _then(_value.copyWith(
      rootId: rootId == freezed ? _value.rootId : rootId as String,
      tree: tree == freezed ? _value.tree : tree as TournamentsTree,
    ));
  }
}

abstract class _$TournamentsTreeLoadedCopyWith<$Res>
    implements $TournamentsTreeLoadedCopyWith<$Res> {
  factory _$TournamentsTreeLoadedCopyWith(_TournamentsTreeLoaded value,
          $Res Function(_TournamentsTreeLoaded) then) =
      __$TournamentsTreeLoadedCopyWithImpl<$Res>;
  @override
  $Res call({String rootId, TournamentsTree tree});
}

class __$TournamentsTreeLoadedCopyWithImpl<$Res>
    extends _$TournamentsTreeLoadedCopyWithImpl<$Res>
    implements _$TournamentsTreeLoadedCopyWith<$Res> {
  __$TournamentsTreeLoadedCopyWithImpl(_TournamentsTreeLoaded _value,
      $Res Function(_TournamentsTreeLoaded) _then)
      : super(_value, (v) => _then(v as _TournamentsTreeLoaded));

  @override
  _TournamentsTreeLoaded get _value => super._value as _TournamentsTreeLoaded;

  @override
  $Res call({
    Object rootId = freezed,
    Object tree = freezed,
  }) {
    return _then(_TournamentsTreeLoaded(
      rootId: rootId == freezed ? _value.rootId : rootId as String,
      tree: tree == freezed ? _value.tree : tree as TournamentsTree,
    ));
  }
}

class _$_TournamentsTreeLoaded
    with DiagnosticableTreeMixin
    implements _TournamentsTreeLoaded {
  const _$_TournamentsTreeLoaded({@required this.rootId, @required this.tree})
      : assert(rootId != null),
        assert(tree != null);

  @override
  final String rootId;
  @override
  final TournamentsTree tree;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TournamentsTreeLoaded(rootId: $rootId, tree: $tree)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TournamentsTreeLoaded'))
      ..add(DiagnosticsProperty('rootId', rootId))
      ..add(DiagnosticsProperty('tree', tree));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TournamentsTreeLoaded &&
            (identical(other.rootId, rootId) ||
                const DeepCollectionEquality().equals(other.rootId, rootId)) &&
            (identical(other.tree, tree) ||
                const DeepCollectionEquality().equals(other.tree, tree)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(rootId) ^
      const DeepCollectionEquality().hash(tree);

  @override
  _$TournamentsTreeLoadedCopyWith<_TournamentsTreeLoaded> get copyWith =>
      __$TournamentsTreeLoadedCopyWithImpl<_TournamentsTreeLoaded>(
          this, _$identity);
}

abstract class _TournamentsTreeLoaded implements TournamentsTreeLoaded {
  const factory _TournamentsTreeLoaded(
      {@required String rootId,
      @required TournamentsTree tree}) = _$_TournamentsTreeLoaded;

  @override
  String get rootId;
  @override
  TournamentsTree get tree;
  @override
  _$TournamentsTreeLoadedCopyWith<_TournamentsTreeLoaded> get copyWith;
}
